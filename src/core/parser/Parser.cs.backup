using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;
using Ouroboros.Tokens;
using Ouroboros.Core.AST;

namespace Ouroboros.Core.Parser
{
    /// <summary>
    /// Recursive descent parser for the Ouroboros language
    /// Supports all three syntax levels: High, Medium, and Low
    /// </summary>
    public class Parser
    {
        private readonly List<Token> _tokens;
        private int _current = 0;
        private SyntaxLevel _currentSyntaxLevel = SyntaxLevel.Medium;

        public Parser(List<Token> tokens)
        {
            _tokens = tokens;
            
            // Write debug info to file
            try
            {
                var debugFile = "parser_debug.txt";
                var debugInfo = new System.Text.StringBuilder();
                debugInfo.AppendLine($"Parser constructor: Received {tokens.Count} tokens");
                
                if (tokens.Count > 0)
                {
                    debugInfo.AppendLine($"First 20 tokens:");
                    for (int i = 0; i < Math.Min(20, tokens.Count); i++)
                    {
                        var t = tokens[i];
                        debugInfo.AppendLine($"  Token {i}: Line={t.Line} Col={t.Column} Type={t.Type} Lexeme='{t.Lexeme}'");
                    }
                }
                
                System.IO.File.WriteAllText(debugFile, debugInfo.ToString());
            }
            catch { }
        }

        public Ouroboros.Core.AST.Program Parse()
        {
            var statements = new List<Statement>();

            while (!IsAtEnd())
            {
                try
                {
                    // Check if this is definitely a declaration token that should never be a statement
                    var current = Current();
                    if (current.Type == TokenType.Namespace || current.Type == TokenType.Using || 
                        current.Type == TokenType.Import || current.Type == TokenType.Class || 
                        current.Type == TokenType.Interface || current.Type == TokenType.Struct || 
                        current.Type == TokenType.Enum || current.Type == TokenType.Function ||
                        current.Type == TokenType.HighLevel || current.Type == TokenType.MediumLevel || 
                        current.Type == TokenType.LowLevel || current.Type == TokenType.Assembly)
                    {
                        // These are always declarations, never statements
                        var declaration = ParseDeclaration();
                        statements.Add(declaration);
                    }
                    else
                    {
                    // Try to parse as declaration first
                    var savedPosition = _current;
                    try
                    {
                        var declaration = ParseDeclaration();
                        statements.Add(declaration);
                    }
                    catch (ParseException)
                    {
                        // If declaration parsing fails, try as statement  
                        _current = savedPosition;
                        var stmt = ParseStatement();
                        statements.Add(stmt);
                        }
                    }
                }
                catch (ParseException error)
                {
                    Console.WriteLine($"Parse error: {error.Message}");
                    Synchronize();
                    throw;
                }
            }

            return new Ouroboros.Core.AST.Program(statements);
        }

        #region Declaration Parsing

        private Statement ParseDeclaration()
        {
            try
            {
                // Skip any attributes before the declaration
                SkipAttributes();
                
                // Check for syntax level markers
                SyntaxLevel? scopedSyntaxLevel = null;
                if (Match(TokenType.HighLevel, TokenType.MediumLevel, TokenType.LowLevel, TokenType.Assembly))
                {
                    scopedSyntaxLevel = Previous().Type switch
                    {
                        TokenType.HighLevel => SyntaxLevel.High,
                        TokenType.MediumLevel => SyntaxLevel.Medium,
                        TokenType.LowLevel => SyntaxLevel.Low,
                        TokenType.Assembly => SyntaxLevel.Assembly,
                        _ => SyntaxLevel.Medium
                    };

                    // For function declarations, we'll apply the syntax level in ParseFunctionDeclaration
                    // For other declarations, apply it immediately
                    if (!Check(TokenType.Function))
                    {
                        var previousLevel = _currentSyntaxLevel;
                        _currentSyntaxLevel = scopedSyntaxLevel.Value;
                        var declaration = ParseDeclaration();
                        _currentSyntaxLevel = previousLevel;
                        return declaration;
                    }
                }

                // Handle unsafe statements at declaration level
                if (Match(TokenType.Unsafe)) return ParseUnsafeStatement();

                // Collect modifiers
                var modifiers = ParseModifiers();

                // Parse declarations based on keyword
                Console.WriteLine($"DEBUG: ParseDeclaration - checking declarations for {Current().Type} '{Current().Lexeme}'");
                if (Match(TokenType.Class)) return ParseClass(modifiers);
                if (Match(TokenType.Interface)) return ParseInterface(modifiers);
                if (Match(TokenType.Struct)) return ParseStruct(modifiers);
                if (Match(TokenType.UnionKeyword)) return ParseUnion(modifiers);
                if (Match(TokenType.Enum)) return ParseEnum(modifiers);
                Console.WriteLine($"DEBUG: ParseDeclaration - About to check for Domain, current token: {Current().Type}");
                if (Check(TokenType.Domain))
                {
                    Console.WriteLine($"DEBUG: ParseDeclaration - Found Domain token, calling ParseDomain");
                    Match(TokenType.Domain);
                    return ParseDomain(modifiers);
                }
                Console.WriteLine($"DEBUG: ParseDeclaration - Domain check failed, current token: {Current().Type}");
                if (Match(TokenType.Function)) 
                {
                    return ParseFunctionDeclaration(modifiers, scopedSyntaxLevel);
                }

                                // Continue with rest of parsing...
                if (Match(TokenType.Namespace)) return ParseNamespace();
                if (Match(TokenType.Using, TokenType.Import)) return ParseUsing();

                if (Match(TokenType.Alias)) return ParseTypeAlias();
                if (Match(TokenType.Type)) return ParseTypeAlias(); // Support both 'alias' and 'type' keywords

                // Data-oriented declarations
                if (Match(TokenType.Component)) return ParseComponent(modifiers);
                if (Match(TokenType.System)) return ParseSystem(modifiers);
                if (Match(TokenType.Entity)) return ParseEntity(modifiers);

                // Check for operator overloading
                if (Match(TokenType.Identifier) && Previous().Lexeme == "operator")
                {
                    return ParseOperatorOverload(modifiers);
                }

                // Check for type declaration followed by identifier (field or method)
                if (PeekType() != null)
                {
                    var type = ParseType();
                    var name = ConsumeIdentifierOrGreekLetter("Expected name after type.");

                    if (Match(TokenType.LeftParen))
                    {
                        // It's a method declaration
                        // Backtrack and parse as function
                        _current--;
                        return ParseFunctionWithSyntaxLevel(type, name, modifiers, scopedSyntaxLevel);
                    }
                    else
                    {
                        // It's a field declaration
                        return ParseField(type, name, modifiers);
                    }
                }

                throw Error(Current(), "Expected declaration.");
            }
            catch (ParseException ex)
            {
                Console.WriteLine($"Error parsing declaration: {ex.Message}");
                throw;
            }
        }

        private ClassDeclaration ParseClass(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected class name.");
            var typeParameters = ParseTypeParameters();

            TypeNode baseClass = null;
            var interfaces = new List<TypeNode>();

            if (Match(TokenType.Colon))
            {
                baseClass = ParseType();
                while (Match(TokenType.Comma))
                {
                    interfaces.Add(ParseType());
                }
            }

            Consume(TokenType.LeftBrace, "Expected '{' before class body.");

            var members = new List<Declaration>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                try
                {
                    var member = (Declaration)ParseDeclaration();
                    members.Add(member);
                }
                catch (ParseException ex)
                {
                    // Log the error with context
                    Console.WriteLine($"Error parsing class member at line {Current().Line}: {ex.Message}");
                    throw;
                }
            }

            Consume(TokenType.RightBrace, "Expected '}' after class body.");

            return new ClassDeclaration(Previous(), name, baseClass, interfaces, members, typeParameters, modifiers);
        }

        private InterfaceDeclaration ParseInterface(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected interface name.");
            var typeParameters = ParseTypeParameters();

            var baseInterfaces = new List<TypeNode>();
            if (Match(TokenType.Colon))
            {
                do
                {
                    baseInterfaces.Add(ParseType());
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.LeftBrace, "Expected '{' before interface body.");

            var members = new List<Declaration>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                // Check for compact field syntax: x, y, z: type;
                if (IsCompactFieldDeclaration())
                {
                    members.AddRange(ParseCompactFieldDeclaration());
                }
                else
                {
                    members.Add((Declaration)ParseDeclaration());
                }
            }

            Consume(TokenType.RightBrace, "Expected '}' after interface body.");

            return new InterfaceDeclaration(Previous(), name, baseInterfaces, members, typeParameters, modifiers);
        }

        private StructDeclaration ParseStruct(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected struct name.");
            var typeParameters = ParseTypeParameters();

            var interfaces = new List<TypeNode>();
            if (Match(TokenType.Colon))
            {
                do
                {
                    interfaces.Add(ParseType());
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.LeftBrace, "Expected '{' before struct body.");

            var members = new List<Declaration>();
            
            // Store current syntax level and temporarily switch to Medium for struct body parsing
            // This ensures field parsing doesn't get routed through low-level statement parsing
            var savedSyntaxLevel = _currentSyntaxLevel;
            _currentSyntaxLevel = SyntaxLevel.Medium;
            
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                                // Check for compact field syntax: x, y, z: type;
                if (IsCompactFieldDeclaration())
                {
                    members.AddRange(ParseCompactFieldDeclaration());
                }
                else
                {
                    members.Add((Declaration)ParseDeclaration());
                }
            }
            
            // Restore the original syntax level
            _currentSyntaxLevel = savedSyntaxLevel;

            Consume(TokenType.RightBrace, "Expected '}' after struct body.");

            return new StructDeclaration(Previous(), name, interfaces, members, typeParameters, modifiers);
        }

        private StructDeclaration ParseUnion(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected union name.");
            var typeParameters = ParseTypeParameters();

            var interfaces = new List<TypeNode>();
            if (Match(TokenType.Colon))
            {
                do
                {
                    interfaces.Add(ParseType());
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.LeftBrace, "Expected '{' before union body.");

            var members = new List<Declaration>();

            // Store current syntax level and temporarily switch to Medium for union body parsing
            // This ensures field parsing doesn't get routed through low-level statement parsing
            var savedSyntaxLevel = _currentSyntaxLevel;
            _currentSyntaxLevel = SyntaxLevel.Medium;

            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                // Check for compact field syntax: x, y, z: type;
                if (IsCompactFieldDeclaration())
                {
                    members.AddRange(ParseCompactFieldDeclaration());
                }
                // Check for function declarations within union
                else if (Match(TokenType.Function))
                {
                    members.Add(ParseFunctionDeclaration(new List<Modifier>(), null));
                }
                else
                {
                    members.Add((Declaration)ParseDeclaration());
                }
            }

            // Restore the original syntax level
            _currentSyntaxLevel = savedSyntaxLevel;

            Consume(TokenType.RightBrace, "Expected '}' after union body.");

            // For now, we'll represent unions as structs since they have similar structure
            // In a real implementation, you'd want a separate UnionDeclaration AST node
            return new StructDeclaration(Previous(), name, interfaces, members, typeParameters, modifiers);
        }

        private bool IsCompactFieldDeclaration()
        {
            // Check: identifier or certain keywords followed by comma or colon suggests compact field
            // Allow keywords like 'length', 'width', 'area' etc. to be used as field names
            if (Check(TokenType.Identifier) || Check(TokenType.Length) || Check(TokenType.Width) || 
                Check(TokenType.Area))
            {
                var current = Current();
                var next = PeekNext();
                Console.WriteLine($"DEBUG: IsCompactFieldDeclaration - Current: {current?.Lexeme} ({current?.Type}), Next: {next?.Lexeme} ({next?.Type})");
                
                if (next?.Type == TokenType.Comma || next?.Type == TokenType.Colon)
                {
                    Console.WriteLine($"DEBUG: IsCompactFieldDeclaration - MATCH! Returning true");
                    return true;
                }
            }
            
            Console.WriteLine($"DEBUG: IsCompactFieldDeclaration - NO MATCH, returning false");
            return false;
        }
        
        private List<Declaration> ParseCompactFieldDeclaration()
        {
            var declarations = new List<Declaration>();
            var fieldNames = new List<Token>();
            
            // Parse comma-separated field names: x, y, z OR single field name: magic, length, etc.
            // Accept identifiers and certain keywords as field names
            fieldNames.Add(ConsumeFieldName("Expected field name"));
            
            while (Match(TokenType.Comma))
            {
                fieldNames.Add(ConsumeFieldName("Expected field name after comma"));
            }
            
            // Parse type after colon: : float OR : u32
            Consume(TokenType.Colon, "Expected ':' after field names");
            var fieldType = ParseType();
            
            // Consume semicolon
            Consume(TokenType.Semicolon, "Expected ';' after field declaration");
            
            // Create individual field declarations for each name
            foreach (var fieldName in fieldNames)
            {
                var field = new FieldDeclaration(fieldName, fieldType, null, new List<Modifier>());
                declarations.Add(field);
            }
            
            return declarations;
        }
        
        private Token ConsumeFieldName(string message)
        {
            // Accept identifiers and certain keywords as field names
            if (Check(TokenType.Identifier) || Check(TokenType.Length) || Check(TokenType.Width) || 
                Check(TokenType.Area) || Check(TokenType.Numbers))
            {
                return Advance();
            }
            
            throw Error(Current(), message);
        }

        private EnumDeclaration ParseEnum(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected enum name.");

            TypeNode underlyingType = null;
            if (Match(TokenType.Colon))
            {
                underlyingType = ParseType();
            }

            Consume(TokenType.LeftBrace, "Expected '{' before enum body.");

            var members = new List<EnumMember>();
            do
            {
                var memberName = Consume(TokenType.Identifier, "Expected enum member name.");
                Expression value = null;

                if (Match(TokenType.Assign))
                {
                    value = ParseExpression();
                }

                members.Add(new EnumMember(memberName.Lexeme, value));
            } while (Match(TokenType.Comma) && !Check(TokenType.RightBrace));

            Consume(TokenType.RightBrace, "Expected '}' after enum body.");

            return new EnumDeclaration(Previous(), name, underlyingType, members, modifiers);
        }

        private DomainDeclaration ParseDomain(List<Modifier> modifiers)
        {
            Console.WriteLine($"DEBUG: ParseDomain() called");
            var name = Consume(TokenType.Identifier, "Expected domain name.");
            Console.WriteLine($"DEBUG: ParseDomain() - domain name: {name.Lexeme}");
            
            Console.WriteLine($"DEBUG: ParseDomain() - expecting left brace, current token: {Current().Type} '{Current().Lexeme}'");
            Consume(TokenType.LeftBrace, "Expected '{' before domain body.");
            Console.WriteLine($"DEBUG: ParseDomain() - found left brace, starting body parsing");

            var members = new List<Statement>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                Console.WriteLine($"DEBUG: ParseDomain - parsing member at {Current().Type} '{Current().Lexeme}' line {Current().Line}");
                // Parse domain members (operator bindings, constants, etc.)
                if (IsDomainOperatorMapping())
                {
                    Console.WriteLine($"DEBUG: ParseDomain - detected operator mapping");
                    // Parse operator mapping: "× means cross_product for Vector3;"
                    var mapping = ParseDomainOperatorMapping();
                    members.Add(mapping);
                }
                else if (Check(TokenType.Const))
                {
                    Console.WriteLine($"DEBUG: ParseDomain - detected const declaration");
                    // Parse constant declarations within domains
                    var constDecl = ParseConstDeclaration();
                    members.Add(constDecl);
                }
                else
                {
                    Console.WriteLine($"DEBUG: ParseDomain - parsing as regular statement");
                    // Parse regular statements
                    var member = ParseStatement();
                    members.Add(member);
                }
            }

            Console.WriteLine($"DEBUG: ParseDomain() - expecting right brace, current token: {Current().Type} '{Current().Lexeme}'");
            Consume(TokenType.RightBrace, "Expected '}' after domain body.");
            
            Console.WriteLine($"DEBUG: ParseDomain() - completed successfully with {members.Count} members");
            return new DomainDeclaration(Previous(), name, members, modifiers);
        }

        private VariableDeclaration ParseConstDeclaration()
        {
            // Parse: const identifier = expression;
            Consume(TokenType.Const, "Expected 'const' keyword.");
            
            // Handle mathematical Unicode identifiers like ε₀, μ₀, etc.
            // Some Unicode characters might be tokenized as multiple tokens, so we need to handle this
            Token name;
            
            // Handle Greek letters and math symbols that may be followed by subscripts/superscripts
            if (IsGreekLetterOrMathSymbol(Current().Type))
            {
                var nameBuilder = new StringBuilder();
                var startToken = Current();
                
                // Start with the Greek letter or math symbol
                nameBuilder.Append(Advance().Lexeme);
                
                // Continue collecting subscripts, superscripts, or other identifier parts
                while (!Check(TokenType.Assign) && !IsAtEnd() && !Check(TokenType.Semicolon) && !Check(TokenType.RightBrace))
                {
                    var currentToken = Current();
                    
                    // If we hit a clear non-identifier token (except subscripts/superscripts), stop
                    if (currentToken.Type == TokenType.Means || currentToken.Type == TokenType.For ||
                        currentToken.Type == TokenType.Const || currentToken.Type == TokenType.LeftBrace)
                        break;
                        
                    // Check if this looks like a subscript/superscript or continuation of identifier
                    var nextLexeme = currentToken.Lexeme;
                    if (nextLexeme.Length > 0)
                    {
                        var firstChar = nextLexeme[0];
                        // Include subscripts (₀₁₂₃...), superscripts, and other identifier chars
                        if (char.IsLetterOrDigit(firstChar) || 
                            (firstChar >= '\u2080' && firstChar <= '\u208E') || // Subscripts
                            (firstChar >= '\u2070' && firstChar <= '\u209F') || // Superscripts  
                            firstChar == '_' ||
                            char.GetUnicodeCategory(firstChar) == UnicodeCategory.NonSpacingMark ||
                            char.GetUnicodeCategory(firstChar) == UnicodeCategory.ModifierSymbol)
                        {
                            nameBuilder.Append(Advance().Lexeme);
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                
                // Create a synthetic identifier token with the combined name
                name = new Token(TokenType.Identifier, nameBuilder.ToString(), nameBuilder.ToString(),
                    startToken.Line, startToken.Column, startToken.StartPosition, startToken.EndPosition,
                    startToken.FileName, startToken.SyntaxLevel);
            }
            else if (Check(TokenType.Identifier))
            {
                name = Advance();
            }
            else
            {
                // For other complex Unicode identifiers that may be split across tokens,
                // combine tokens until we hit the '=' sign
                var nameBuilder = new StringBuilder();
                var startToken = Current();
                
                while (!Check(TokenType.Assign) && !IsAtEnd() && !Check(TokenType.Semicolon) && !Check(TokenType.RightBrace))
                {
                    var token = Advance();
                    nameBuilder.Append(token.Lexeme);
                    
                    // Stop if we've collected a reasonable identifier and the next is '='
                    if (nameBuilder.Length > 0 && Check(TokenType.Assign))
                        break;
                }
                
                // Create a synthetic identifier token
                name = new Token(TokenType.Identifier, nameBuilder.ToString(), nameBuilder.ToString(),
                    startToken.Line, startToken.Column, startToken.StartPosition, startToken.EndPosition,
                    startToken.FileName, startToken.SyntaxLevel);
            }
            
            Consume(TokenType.Assign, "Expected '=' after constant name.");
            var initializer = ParseExpression();
            Consume(TokenType.Semicolon, "Expected ';' after constant declaration.");
            
            // Create a variable declaration with isConst = true
            // Use a dummy type node since constants infer their type
            var constType = new TypeNode("const");
            return new VariableDeclaration(constType, name, initializer, true, false);
        }

        private bool IsDomainOperatorMapping()
        {
            // Check if current statement is an operator mapping like "× means cross_product"
            // Look ahead to see if pattern is: [symbol] "means" [identifier]
            var savedPosition = _current;
            
            try
            {
                // Skip the operator symbol (could be various mathematical symbols)
                if (IsAtEnd()) return false;
                Console.WriteLine($"DEBUG: IsDomainOperatorMapping() checking {Current().Type} '{Current().Lexeme}'");
                Advance();
                
                // Check if followed by "means"
                if (Check(TokenType.Means))
                {
                    Console.WriteLine($"DEBUG: IsDomainOperatorMapping() - Found 'means' keyword, returning true");
                    return true;
                }
                
                Console.WriteLine($"DEBUG: IsDomainOperatorMapping() - Next token is {Current().Type} '{Current().Lexeme}', returning false");
                return false;
            }
            finally
            {
                _current = savedPosition;
            }
        }

        private Statement ParseDomainOperatorMapping()
        {
            // Parse: "× means cross_product for Vector3;"
            // or: "∇ means gradient_operator;"
            
            var operatorSymbol = Advance(); // Consume the operator symbol
            
            // Consume "means" keyword
            if (!Check(TokenType.Means))
            {
                throw Error(Current(), "Expected 'means' after operator symbol in domain mapping.");
            }
            Advance(); // consume "means"
            
            // Parse function name
            var functionName = Consume(TokenType.Identifier, "Expected function name after 'means'.");
            
            // Parse optional "for Type" clause
            Token? typeName = null;
            if (Check(TokenType.For))
            {
                Advance(); // consume "for"
                typeName = Consume(TokenType.Identifier, "Expected type name after 'for'.");
            }
            
            Consume(TokenType.Semicolon, "Expected ';' after domain operator mapping.");
            
            // For now, create an expression statement to represent this
            // In a full implementation, this would be a custom AST node type
            var mappingToken = new Token(TokenType.StringLiteral, 
                $"operator_mapping: {operatorSymbol.Lexeme} -> {functionName.Lexeme}" + 
                (typeName != null ? $" for {typeName.Lexeme}" : ""),
                $"operator_mapping: {operatorSymbol.Lexeme} -> {functionName.Lexeme}" + 
                (typeName != null ? $" for {typeName.Lexeme}" : ""),
                operatorSymbol.Line, operatorSymbol.Column, operatorSymbol.StartPosition, operatorSymbol.EndPosition,
                operatorSymbol.FileName, operatorSymbol.SyntaxLevel);
            
            var mappingExpr = new LiteralExpression(mappingToken);
            
            return new ExpressionStatement(mappingExpr);
        }

        private FunctionDeclaration ParseFunction(TypeNode returnType, Token name, List<Modifier> modifiers, List<TypeParameter> typeParameters = null)
        {
            // Consume the opening parenthesis
            Consume(TokenType.LeftParen, "Expected '(' before parameters.");
            
            var parameters = ParseParameters();
            // Type parameters are now passed in from ParseDeclaration
            if (typeParameters == null)
            {
                typeParameters = new List<TypeParameter>();
            }

            BlockStatement body = null;
            if (Match(TokenType.DoubleArrow))
            {
                // Expression-bodied function
                var expr = ParseExpression();
                body = new BlockStatement(new List<Statement> 
                { 
                    new ReturnStatement(Previous(), expr) 
                });
                Consume(TokenType.Semicolon, "Expected ';' after expression body.");
            }
            else
            {
                Consume(TokenType.LeftBrace, "Expected '{' before function body.");
                // The current syntax level should be preserved for parsing the body
                body = ParseBlock();
            }

            bool isAsync = modifiers.Contains(Modifier.Async);
            return new FunctionDeclaration(name, returnType, parameters, body, typeParameters, isAsync, modifiers);
        }

        private FunctionDeclaration ParseFunctionWithSyntaxLevel(TypeNode returnType, Token name, List<Modifier> modifiers, SyntaxLevel? scopedSyntaxLevel, List<TypeParameter> typeParameters = null)
        {
            // Store the current syntax level to restore later
            var previousLevel = _currentSyntaxLevel;
            
            // If this function has a scoped syntax level, apply it
            if (scopedSyntaxLevel.HasValue)
            {
                _currentSyntaxLevel = scopedSyntaxLevel.Value;
            }

            try
            {
                // Consume the opening parenthesis
                Consume(TokenType.LeftParen, "Expected '(' before parameters.");
                
                var parameters = ParseParameters();
                // Type parameters are now passed in from ParseDeclaration
                if (typeParameters == null)
                {
                    typeParameters = new List<TypeParameter>();
                }

                BlockStatement body = null;
                if (Match(TokenType.DoubleArrow))
                {
                    // Expression-bodied function
                    var expr = ParseExpression();
                    body = new BlockStatement(new List<Statement> 
                    { 
                        new ReturnStatement(Previous(), expr) 
                    });
                    Consume(TokenType.Semicolon, "Expected ';' after expression body.");
                }
                else
                {
                    Consume(TokenType.LeftBrace, "Expected '{' before function body.");
                    // The current syntax level is maintained for parsing the body
                    body = ParseBlock();
                }

                bool isAsync = modifiers.Contains(Modifier.Async);
                return new FunctionDeclaration(name, returnType, parameters, body, typeParameters, isAsync, modifiers);
            }
            finally
            {
                // Restore the previous syntax level
                _currentSyntaxLevel = previousLevel;
            }
        }

        private FunctionDeclaration ParseFunctionDeclaration(List<Modifier> modifiers, SyntaxLevel? scopedSyntaxLevel = null)
        {
            // Store the current syntax level to restore later
            var previousLevel = _currentSyntaxLevel;
            
            // If this function has a scoped syntax level, apply it
            if (scopedSyntaxLevel.HasValue)
            {
                _currentSyntaxLevel = scopedSyntaxLevel.Value;
            }

            try
            {
                // Parse Ouroboros syntax: function FunctionName(): ReturnType {
                var name = Consume(TokenType.Identifier, "Expected function name.");
                
                // Parse parameters
                Consume(TokenType.LeftParen, "Expected '(' after function name.");
                
                // Check if we should use Ouroboros-style parameters (name: type) or C# style (type name)
                // Peek ahead to see if we have identifier followed by colon
                List<Parameter> parameters;
                if (!Check(TokenType.RightParen) && Current().Type == TokenType.Identifier && PeekNext()?.Type == TokenType.Colon)
                {
                    // Ouroboros style: name: type
                    parameters = ParseOuroborosParameters();
                }
                else
                {
                    // C# style: type name
                    parameters = ParseParameters();
                }
                
                // Parse return type - support both ':' and '->' syntax
                TypeNode returnType;
                if (Match(TokenType.Colon))
                {
                    // Ouroboros syntax: function name(): type
                    returnType = ParseType();
                }
                else if (Check(TokenType.Arrow))
                {
                    // Arrow syntax: function name() -> type (using correct TokenType.Arrow)
                    Advance(); // consume the ->
                    returnType = ParseType();
                }
                else
                {
                    // Default to void if no return type specified
                    returnType = new TypeNode("void");
                }
                
                // Parse type parameters (if any) - for generic functions
                var typeParameters = new List<TypeParameter>();
                
                // Parse function body - this will maintain the current syntax level
                BlockStatement body = null;
                if (Match(TokenType.DoubleArrow))
                {
                    // Expression-bodied function
                    var expr = ParseExpression();
                    body = new BlockStatement(new List<Statement> 
                    { 
                        new ReturnStatement(Previous(), expr) 
                    });
                    Consume(TokenType.Semicolon, "Expected ';' after expression body.");
                }
                else
                {
                    Consume(TokenType.LeftBrace, "Expected '{' before function body.");
                    // The current syntax level is maintained for parsing the body
                    body = ParseBlock();
                }

                bool isAsync = modifiers.Contains(Modifier.Async);
                return new FunctionDeclaration(name, returnType, parameters, body, typeParameters, isAsync, modifiers);
            }
            finally
            {
                // Restore the previous syntax level
                _currentSyntaxLevel = previousLevel;
            }
        }

        private FieldDeclaration ParseField(TypeNode type, Token name, List<Modifier> modifiers)
        {
            Expression initializer = null;
            if (Match(TokenType.Assign))
            {
                initializer = ParseExpression();
            }

            Consume(TokenType.Semicolon, "Expected ';' after field declaration.");

            return new FieldDeclaration(name, type, initializer, modifiers);
        }

        private FunctionDeclaration ParseOperatorOverload(List<Modifier> modifiers)
        {
            // Store the current syntax level to restore later
            var previousLevel = _currentSyntaxLevel;
            
            try
            {
                // The operator overload should use the current syntax level (e.g., @low)
                // No need to change _currentSyntaxLevel here - it should already be set correctly
                
                // Parse the operator symbol: [], +, -, *, /, etc.
                Token operatorToken;
                string operatorName;
                
                if (Match(TokenType.LeftBracket))
                {
                    // Array indexer operator []
                    Consume(TokenType.RightBracket, "Expected ']' after '[' for indexer operator.");
                    operatorName = "op_Index";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Plus))
                {
                    operatorName = "op_Addition";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Minus))
                {
                    operatorName = "op_Subtraction";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Multiply))
                {
                    operatorName = "op_Multiply";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Divide))
                {
                    operatorName = "op_Division";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Modulo))
                {
                    operatorName = "op_Modulus";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Equal))
                {
                    operatorName = "op_Equality";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.NotEqual))
                {
                    operatorName = "op_Inequality";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Less))
                {
                    operatorName = "op_LessThan";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.Greater))
                {
                    operatorName = "op_GreaterThan";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.LessEqual))
                {
                    operatorName = "op_LessThanOrEqual";
                    operatorToken = Previous();
                }
                else if (Match(TokenType.GreaterEqual))
                {
                    operatorName = "op_GreaterThanOrEqual";
                    operatorToken = Previous();
                }
                else
                {
                    throw Error(Current(), "Expected operator symbol after 'operator' keyword.");
                }
                
                // Create a synthetic name token for the operator
                var nameToken = new Token(TokenType.Identifier, operatorName, null, 
                                        operatorToken.Line, operatorToken.Column, 
                                        operatorToken.StartPosition, operatorToken.EndPosition,
                                        operatorToken.FileName, operatorToken.SyntaxLevel);
                
                // Parse parameters (Ouroboros style: name: type)
                Consume(TokenType.LeftParen, "Expected '(' after operator symbol.");
                var parameters = ParseOuroborosParameters();
                
                // Parse return type
                Consume(TokenType.Arrow, "Expected '->' before return type.");
                var returnType = ParseType();
                
                // Parse function body - preserve current syntax level for the body
                BlockStatement body;
                if (Match(TokenType.LeftBrace))
                {
                    // The current syntax level is maintained for parsing the body
                    body = ParseBlock();
                }
                else
                {
                    throw Error(Current(), "Expected '{' before operator body.");
                }
                
                // Mark as operator overload
                modifiers.Add(Modifier.Operator);
                
                return new FunctionDeclaration(nameToken, returnType, parameters, body, 
                                             new List<TypeParameter>(), false, modifiers);
            }
            finally
            {
                // Restore the previous syntax level
                _currentSyntaxLevel = previousLevel;
            }
        }

        private List<Parameter> ParseOuroborosParameters()
        {
            var parameters = new List<Parameter>();

            if (!Check(TokenType.RightParen))
            {
                do
                {
                    var modifier = ParameterModifier.None;
                    
                    // Parse parameter modifiers if any
                    if (Match(TokenType.Ref)) modifier = ParameterModifier.Ref;
                    else if (Match(TokenType.Out)) modifier = ParameterModifier.Out;
                    else if (Match(TokenType.In)) modifier = ParameterModifier.In;
                    else if (Match(TokenType.Params)) modifier = ParameterModifier.Params;

                    // Parse parameter name
                    var name = ConsumeIdentifier("Expected parameter name.");

                    // Parse colon
                    Consume(TokenType.Colon, "Expected ':' after parameter name.");
                    
                    // Parse parameter type
                    var type = ParseType();

                    Expression defaultValue = null;
                    if (Match(TokenType.Assign))
                    {
                        defaultValue = ParseAssignment();
                    }

                    parameters.Add(new Parameter(type, name.Lexeme, defaultValue, modifier));
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.RightParen, "Expected ')' after parameters.");
            return parameters;
        }

        // Data-oriented declarations
        private ComponentDeclaration ParseComponent(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected component name.");
            Consume(TokenType.LeftBrace, "Expected '{' before component body.");

            var fields = new List<FieldDeclaration>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                var fieldModifiers = ParseModifiers();
                var type = ParseType();
                var fieldName = Consume(TokenType.Identifier, "Expected field name.");
                Expression initializer = null;
                
                if (Match(TokenType.Assign))
                {
                    initializer = ParseExpression();
                }
                
                Consume(TokenType.Semicolon, "Expected ';' after field.");
                fields.Add(new FieldDeclaration(fieldName, type, initializer, fieldModifiers));
            }

            Consume(TokenType.RightBrace, "Expected '}' after component body.");

            return new ComponentDeclaration(Previous(), name, fields, modifiers);
        }

        private SystemDeclaration ParseSystem(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected system name.");
            
            var requiredComponents = new List<TypeNode>();
            if (Match(TokenType.LeftBracket))
            {
                do
                {
                    requiredComponents.Add(ParseType());
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.RightBracket, "Expected ']' after component list.");
            }

            Consume(TokenType.LeftBrace, "Expected '{' before system body.");

            var methods = new List<FunctionDeclaration>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                var methodModifiers = ParseModifiers();
                var returnType = ParseType();
                var methodName = Consume(TokenType.Identifier, "Expected method name.");
                methods.Add(ParseFunction(returnType, methodName, methodModifiers, null));
            }

            Consume(TokenType.RightBrace, "Expected '}' after system body.");

            return new SystemDeclaration(Previous(), name, requiredComponents, methods, modifiers);
        }

        private EntityDeclaration ParseEntity(List<Modifier> modifiers)
        {
            var name = Consume(TokenType.Identifier, "Expected entity name.");
            
            var components = new List<TypeNode>();
            if (Match(TokenType.LeftBracket))
            {
                do
                {
                    components.Add(ParseType());
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.RightBracket, "Expected ']' after component list.");
            }

            Consume(TokenType.Semicolon, "Expected ';' after entity declaration.");

            return new EntityDeclaration(Previous(), name, components, modifiers);
        }

        #endregion

        #region High-Level Syntax Parsing

        private Statement ParseHighLevelStatement()
        {
            // Use the comprehensive HighLevelParser for natural language constructs
            var highParser = new Ouroboros.Syntaxes.High.HighLevelParser(_tokens);
            highParser.SetCurrentPosition(_current);
            
            try
            {
                var statement = highParser.ParseHighLevelStatement();
                _current = highParser.GetCurrentPosition();
                return statement;
            }
            catch (Exception ex)
            {
                // Fall back to the simpler parsing if HighLevelParser fails
                // This ensures backward compatibility
                Console.WriteLine($"DEBUG: HighLevelParser failed with: {ex.Message}");
                Console.WriteLine($"DEBUG: At token: {Current().Type} '{Current().Lexeme}' at line {Current().Line}");
                return ParseHighLevelStatementFallback();
                    }
                }

        private Statement ParseHighLevelStatementFallback()
        {
            // Original simple high-level parsing for backward compatibility
            // Check for print statement
            if (Check(TokenType.Print))
                {
                Advance(); // consume 'print'
                var expr = ParseExpression();
                
                // Convert print to Console.WriteLine
                var printCall = new CallExpression(
                    new IdentifierExpression(
                        new Token(TokenType.Identifier, "Console.WriteLine", null, 0, 0, 0, 0, "", _currentSyntaxLevel)),
                    new List<Expression> { expr });
                
                // Semicolon is optional in high-level syntax
                Match(TokenType.Semicolon);
                
                return new ExpressionStatement(printCall);
            }
            
            // Check for natural assignment with :=
            if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.Assign)
                {
                var nameToken = ConsumeIdentifier("Expected variable name.");
                Consume(TokenType.Assign, "Expected ':=' operator.");
                var initializerExpr = ParseExpression();
                
                // Semicolon is optional in high-level syntax
                Match(TokenType.Semicolon);
                
                    var varType = new TypeNode("var");
                return new VariableDeclaration(varType, nameToken, initializerExpr, false, false);
            }
            
            // Fall back to regular statement parsing
            var savedLevel = _currentSyntaxLevel;
            _currentSyntaxLevel = SyntaxLevel.Medium; // Temporarily switch to medium level
            var stmt = ParseStatement();
            _currentSyntaxLevel = savedLevel;
            return stmt;
        }

        private Statement ParseMediumLevelStatement()
        {
            // Temporarily use fallback parsing for medium-level syntax
                    Console.WriteLine($"DEBUG: Using enhanced medium-level parsing");
        return ParseMediumLevelStatementEnhanced();
        }
        
        private Statement ParseMediumLevelStatementFallback()
        {
            // Fallback for medium-level parsing - use standard C#-style parsing
            try
            {
                Console.WriteLine($"DEBUG: Medium fallback at {Current().Type} '{Current().Lexeme}' line {Current().Line}");
                
                // Handle function declarations with modifiers (public static void etc)
                if (Check(TokenType.Public) || Check(TokenType.Private) || Check(TokenType.Protected) || 
                    Check(TokenType.Internal) || Check(TokenType.Static))
                {
                    Console.WriteLine($"DEBUG: Detected function declaration with modifiers");
                    var modifiers = ParseModifiers();
                    if (PeekType() != null || Check(TokenType.Void))
                    {
                        // This looks like a function declaration
                        var returnType = Check(TokenType.Void) ? new TypeNode("void") : ParseType();
                        if (Check(TokenType.Void)) Advance(); // consume void
                        
                        var name = ConsumeIdentifierOrGreekLetter("Expected function name.");
                        return ParseFunction(returnType, name, modifiers);
                    }
                }
                
                // Control flow
                if (Match(TokenType.If)) return ParseIfStatement();
                if (Match(TokenType.While)) return ParseWhileStatement();
                if (Match(TokenType.For)) return ParseForStatement();
                if (Match(TokenType.Return)) return ParseReturnStatement();
                if (Match(TokenType.Break)) return ParseBreakStatement();
                if (Match(TokenType.Continue)) return ParseContinueStatement();
                if (Match(TokenType.Throw)) return ParseThrowStatement();
                if (Match(TokenType.Try)) return ParseTryStatement();
                if (Match(TokenType.LeftBrace)) return ParseBlock();
                
                // Handle print statements (medium-level can be more lenient about semicolons)
                if (Match(TokenType.Print))
                {
                    var printToken = Previous();
                    var expr = ParseAssignment();
                    
                    // Convert print to Console.WriteLine call
                    var printCall = new CallExpression(
                        new IdentifierExpression(
                            new Token(TokenType.Identifier, "Console.WriteLine", null, printToken.Line, 
                                     printToken.Column, printToken.StartPosition, printToken.EndPosition, 
                                     printToken.FileName, _currentSyntaxLevel)),
                        new List<Expression> { expr });
                    
                    // Optional semicolon for print statements in medium level
                    if (Match(TokenType.Semicolon)) { /* consume */ }
                    return new ExpressionStatement(printCall);
                }

                // Function declaration with 'function' keyword
                if (Match(TokenType.Function))
                {
                    return ParseFunctionDeclaration(new List<Modifier>(), null);
                }
                
                // Function declaration without modifiers (void, int, etc.)
                if (Check(TokenType.Void) || PeekType() != null)
                {
                    var returnType = Check(TokenType.Void) ? new TypeNode("void") : ParseType();
                    if (Check(TokenType.Void)) Advance(); // consume void
                    
                    // Check if followed by identifier and then parentheses (function signature)
                    if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.LeftParen)
                    {
                        var name = ConsumeIdentifierOrGreekLetter("Expected function name.");
                        return ParseFunction(returnType, name, new List<Modifier>());
                    }
                    else
                    {
                        // It's a variable declaration
                        var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
                        return ParseVariableDeclaration(returnType, name);
                    }
                }

                // Expression statement
                return ParseExpressionStatement();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Medium-level fallback parsing failed: {ex.Message}");
                throw new ParseException($"Unable to parse medium-level statement at line {Current().Line}");
            }
        }
        
        private Statement ParseMediumLevelStatementEnhanced()
        {
            Console.WriteLine($"DEBUG: Enhanced medium-level parsing at {Current().Type} '{Current().Lexeme}' line {Current().Line}");
            Console.WriteLine($"DEBUG: ENTERING ParseMediumLevelStatementEnhanced method");
            
            try
            {
                Console.WriteLine($"DEBUG: Inside try block");
                // Skip any attributes before parsing the statement
                SkipAttributes();
                Console.WriteLine($"DEBUG: After SkipAttributes, current token: {Current().Type} '{Current().Lexeme}'");
            
            // Check for syntax level markers (@high, @medium, @low, @asm)
            if (Check(TokenType.HighLevel) || Check(TokenType.MediumLevel) || 
                Check(TokenType.LowLevel) || Check(TokenType.Assembly))
            {
                Console.WriteLine($"DEBUG: Detected syntax level marker, delegating to main parser");
                return ParseDeclaration();
            }
            Console.WriteLine($"DEBUG: Not a syntax level marker");
            
            // Check for generic function declarations: T FunctionName<T>(...)
            if (IsGenericFunctionDeclaration())
            {
                Console.WriteLine($"DEBUG: Detected generic function declaration");
                return ParseGenericFunctionDeclaration();
            }
            Console.WriteLine($"DEBUG: IsGenericFunctionDeclaration() returned false for {Current().Type} '{Current().Lexeme}'");
            
            // Check for type declarations
            if (IsTypeDeclarationEnhanced())
            {
                Console.WriteLine($"DEBUG: Detected type declaration");
                Console.WriteLine($"DEBUG: About to call ParseDeclaration() for {Current().Type} '{Current().Lexeme}'");
                // Parse class, struct, interface, enum etc.
                var result = ParseDeclaration();
                Console.WriteLine($"DEBUG: ParseDeclaration() returned successfully");
                return result;
            }
            
            // Check for variable declarations with modern syntax
            if (IsVariableDeclarationEnhanced())
            {
                Console.WriteLine($"DEBUG: Detected variable declaration");
                return ParseVariableDeclarationEnhanced();
            }
            Console.WriteLine($"DEBUG: Not a variable declaration");
            
                        // Check for specific statement types that should use medium-level fallback
            if (Check(TokenType.Print) || Check(TokenType.If) || Check(TokenType.For) ||
                Check(TokenType.While) || Check(TokenType.Return) || Check(TokenType.Break) ||
                Check(TokenType.Continue) || Check(TokenType.Throw) || Check(TokenType.Try) ||
                Check(TokenType.LeftBrace) || Check(TokenType.Function))
            {
                Console.WriteLine($"DEBUG: Using medium-level fallback for statement: {Current().Type}");
                return ParseMediumLevelStatementFallback();
            }
            Console.WriteLine($"DEBUG: Not a medium-level fallback statement");
            
            // Parse as expression statement using enhanced parsing
            Console.WriteLine($"DEBUG: Parsing as expression statement using enhanced parsing");
            var expr = ParseExpression(); // Changed from ParseRangeOrExpression to ParseExpression to handle assignments
            Consume(TokenType.Semicolon, "Expected ';' after expression.");
            return new ExpressionStatement(expr);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG: Exception in ParseMediumLevelStatementEnhanced: {ex.Message}");
                throw;
            }
        }
        
        private bool IsTypeDeclarationEnhanced()
        {
            // Check for class, struct, interface, enum, union, type alias, domain keywords
            var result = Check(TokenType.Class) || Check(TokenType.Struct) || 
                         Check(TokenType.Interface) || Check(TokenType.Enum) ||
                         Check(TokenType.UnionKeyword) || Check(TokenType.Type) ||
                         Check(TokenType.Component) || Check(TokenType.System) || Check(TokenType.Entity) ||
                         Check(TokenType.Domain);
            Console.WriteLine($"DEBUG: IsTypeDeclarationEnhanced() called for {Current().Type} '{Current().Lexeme}' - returning {result}");
            return result;
        }
        
        private bool IsGenericFunctionDeclaration()
        {
            // Save current position
            var savedPosition = _current;
            
            try
            {
                // Check pattern: TypeName FunctionName<...>(...)
                // or: TypeName FunctionName(...)
                if (!Check(TokenType.Identifier) && !IsKnownTypeName(Current()))
                {
                    return false;
                }
                
                Advance(); // consume type
                
                // Must be followed by identifier (function name)
                if (!Check(TokenType.Identifier))
                {
                    return false;
                }
                
                Advance(); // consume function name
                
                // Check for generic type parameters <...> or direct parameters (...)
                bool hasGenericParams = Check(TokenType.Less);
                if (hasGenericParams)
                {
                    // Skip generic parameters
                    int angleCount = 1;
                    Advance(); // consume <
                    while (!IsAtEnd() && angleCount > 0)
                    {
                        if (Check(TokenType.Less)) angleCount++;
                        else if (Check(TokenType.Greater)) angleCount--;
                        Advance();
                    }
                }
                
                // Must be followed by parameter list
                bool hasParameters = Check(TokenType.LeftParen);
                
                return hasParameters;
            }
            finally
            {
                // Restore position
                _current = savedPosition;
            }
        }
        
        private Statement ParseGenericFunctionDeclaration()
        {
            Console.WriteLine($"DEBUG: Parsing generic function declaration");
            
            // Parse return type
            var returnType = ParseType();
            Console.WriteLine($"DEBUG: Parsed return type: {returnType.Name}");
            
            // Parse function name
            var nameToken = Consume(TokenType.Identifier, "Expected function name.");
            Console.WriteLine($"DEBUG: Parsed function name: {nameToken.Lexeme}");
            
            // Parse generic type parameters if present
            List<TypeParameter> typeParameters = null;
            if (Match(TokenType.Less))
            {
                Console.WriteLine($"DEBUG: Parsing generic type parameters");
                typeParameters = new List<TypeParameter>();
                
                do
                {
                    var typeParamName = Consume(TokenType.Identifier, "Expected type parameter name.").Lexeme;
                    typeParameters.Add(new TypeParameter(typeParamName, new List<TypeNode>(), false, false));
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.Greater, "Expected '>' after type parameters.");
            }
            
            // Parse parameters
            Consume(TokenType.LeftParen, "Expected '(' after function name.");
            var parameters = ParseParameters();
            
            // Parse where clause if present (type constraints)
            if (Match(TokenType.Where))
            {
                Console.WriteLine($"DEBUG: Parsing where clause");
                // For now, just skip the where clause - full implementation would parse constraints
                // where T : IComparable<T>
                do
                {
                    // Skip constraint specification
                    while (!Check(TokenType.LeftBrace) && !Check(TokenType.Semicolon) && !IsAtEnd())
                    {
                        Advance();
                    }
                } while (Match(TokenType.Comma));
            }
            
            // Parse function body
            Statement body;
            if (Check(TokenType.LeftBrace))
            {
                body = ParseBlock();
            }
            else
            {
                // Expression body or just semicolon
                if (Match(TokenType.Semicolon))
                {
                    body = new BlockStatement(new List<Statement>());
                }
                else
                {
                    var expr = ParseAssignment();
                    Consume(TokenType.Semicolon, "Expected ';' after expression body.");
                    body = new ExpressionStatement(expr);
                }
            }
            
            Console.WriteLine($"DEBUG: Successfully parsed generic function declaration");
            return new FunctionDeclaration(nameToken, returnType, parameters, body as BlockStatement, typeParameters, false, new List<Modifier>());
        }
        
        private bool IsVariableDeclarationEnhanced()
        {
            int savedPosition = _current;
            
            try
            {
                // Skip modifiers (volatile, static, const, readonly, atomic, etc.)
                while (Check(TokenType.Volatile) || Check(TokenType.Static) || Check(TokenType.Const) || 
                       Check(TokenType.Readonly) || Check(TokenType.Public) || Check(TokenType.Private) ||
                       Check(TokenType.Protected) || Check(TokenType.Internal) || Check(TokenType.Atomic))
                {
                    Advance();
                }
                
                // Check for var keyword after modifiers
                if (Check(TokenType.Var))
                {
                    _current = savedPosition;
                    return true;
                }
                    
                // Check for specific type keywords
                if (Check(TokenType.String) || Check(TokenType.Int) || Check(TokenType.Double) || 
                    Check(TokenType.Bool) || Check(TokenType.Object) || Check(TokenType.Decimal) ||
                    Check(TokenType.Float) || Check(TokenType.Long) || Check(TokenType.Short) ||
                    Check(TokenType.Byte) || Check(TokenType.Char))
                {
                    // Skip type name
                    Advance();
                    
                    // Skip nullable marker if present
                    if (Check(TokenType.Question))
                    {
                        Advance();
                    }
                    
                    // Check if followed by identifier
                    bool isDeclaration = Check(TokenType.Identifier);
                    
                    _current = savedPosition;
                    return isDeclaration;
                }
                    
                // Check if current token could be a type name and next token is an identifier
                if (!Check(TokenType.Identifier))
                {
                    _current = savedPosition;
                    return false;
                }
                
                // Skip type name
                Advance();
                
                // Skip nullable marker if present
                if (Check(TokenType.Question))
                {
                    Advance();
                }
                
                // Check if followed by identifier
                bool isDeclaration2 = Check(TokenType.Identifier);
                
                _current = savedPosition;
                return isDeclaration2;
            }
            catch
            {
                _current = savedPosition;
                return false;
            }
        }
        
        private Statement ParseVariableDeclarationEnhanced()
        {
            Console.WriteLine($"DEBUG: ParseVariableDeclarationEnhanced() starting at token: {Current().Type} '{Current().Lexeme}'");
            
            // Parse modifiers first (volatile, static, const, readonly, atomic, etc.)
            var modifiers = new List<Modifier>();
            while (Check(TokenType.Volatile) || Check(TokenType.Static) || Check(TokenType.Const) || 
                   Check(TokenType.Readonly) || Check(TokenType.Public) || Check(TokenType.Private) ||
                   Check(TokenType.Protected) || Check(TokenType.Internal) || Check(TokenType.Atomic))
            {
                var modifierToken = Advance();
                
                // Map TokenType to Modifier enum
                Modifier modifier = modifierToken.Type switch
                {
                    TokenType.Volatile => Modifier.Volatile,
                    TokenType.Static => Modifier.Static,
                    TokenType.Const => Modifier.Const,
                    TokenType.Readonly => Modifier.Readonly,
                    TokenType.Public => Modifier.Public,
                    TokenType.Private => Modifier.Private,
                    TokenType.Protected => Modifier.Protected,
                    TokenType.Internal => Modifier.Internal,
                    TokenType.Atomic => Modifier.Async, // Using Async as closest equivalent for now
                    _ => throw new InvalidOperationException($"Unexpected modifier token: {modifierToken.Type}")
                };
                
                modifiers.Add(modifier);
                Console.WriteLine($"DEBUG: Parsed modifier: '{modifierToken.Lexeme}'");
            }
            
            TypeNode type;
            string variableName;
            
            // Handle different declaration patterns
            if (Check(TokenType.Var))
            {
                Advance(); // consume 'var'
                Console.WriteLine($"DEBUG: Parsed var keyword: 'var'");
                
                // Parse variable name
                Console.WriteLine($"DEBUG: About to parse variable name, current token: {Current().Type} '{Current().Lexeme}'");
                var nameToken = ConsumeIdentifier("Expected variable name after 'var'.");
                variableName = nameToken.Lexeme;
                Console.WriteLine($"DEBUG: Parsed variable name: '{variableName}'");
                
                // Check for type annotation (: Type)
                if (Match(TokenType.Colon))
                {
                    Console.WriteLine($"DEBUG: Found type annotation, parsing type");
                    type = ParseType();
                    Console.WriteLine($"DEBUG: Parsed type annotation: '{type.Name}'");
                }
                else
                {
                    type = new TypeNode("var");
                }
            }
            else
            {
                // Handle explicit type declarations like "string? nullable_string = null;"
                type = ParseType();
                Console.WriteLine($"DEBUG: Parsed explicit type: '{type.Name}'");
                
                // Check for nullable modifier
                if (Match(TokenType.Question))
                {
                    type = new TypeNode(type.Name, type.TypeArguments, type.IsArray, type.ArrayRank, true, type.IsPointer);
                    Console.WriteLine($"DEBUG: Parsed nullable type: '{type.Name}?'");
                }
                
                Console.WriteLine($"DEBUG: About to parse variable name, current token: {Current().Type} '{Current().Lexeme}'");
                var nameToken = ConsumeIdentifier("Expected variable name after type.");
                variableName = nameToken.Lexeme;
                Console.WriteLine($"DEBUG: Parsed variable name: '{variableName}'");
            }
            
            // Parse initializer
            Expression initializer = null;
            if (Match(TokenType.Assign))
            {
                Console.WriteLine($"DEBUG: Parsing initializer expression");
                
                // Handle collection initializers with braces
                if (Check(TokenType.LeftBrace))
                {
                    initializer = ParseCollectionInitializer();
                }
                else
                {
                    // Use the full expression parsing that includes throw expressions and lambda support
                    initializer = ParseAssignment();
                }
                Console.WriteLine($"DEBUG: Parsed initializer expression");
            }
            
            // Parse memory-mapped I/O 'at' clause for embedded systems
            Expression memoryAddress = null;
            if (Match(TokenType.At))
            {
                Console.WriteLine($"DEBUG: Parsing 'at' clause for memory-mapped variable");
                memoryAddress = ParseAssignment(); // Parse the address expression
                Console.WriteLine($"DEBUG: Parsed memory address expression");
            }
            
            // Consume semicolon
            Console.WriteLine($"DEBUG: About to consume semicolon, current token: {Current().Type} '{Current().Lexeme}'");
            Consume(TokenType.Semicolon, "Expected ';' after variable declaration.");
            Console.WriteLine($"DEBUG: Successfully parsed declaration: {type.Name} {variableName}");
            
            // For now, create a standard variable declaration (the memoryAddress could be stored in a custom node type later)
            return new VariableDeclaration(type, new Token(TokenType.Identifier, variableName, variableName, 0, 0, 0, 0, "", _currentSyntaxLevel), initializer, false, false);
        }
        
        private Expression ParseCollectionInitializer()
        {
            Console.WriteLine($"DEBUG: Parsing collection initializer");
            Consume(TokenType.LeftBrace, "Expected '{' for collection initializer.");
            
            var elements = new List<Expression>();
            
            if (!Check(TokenType.RightBrace))
            {
                do
                {
                    // Handle dictionary-style initializers like ["key"] = value
                    if (Check(TokenType.LeftBracket))
                    {
                        Advance(); // consume '['
                        var key = ParseAssignment();
                        Consume(TokenType.RightBracket, "Expected ']' after dictionary key.");
                        Consume(TokenType.Assign, "Expected '=' after dictionary key.");
                        var value = ParseAssignment();
                        
                        // Create a binary expression to represent key = value
                        elements.Add(new BinaryExpression(key, new Token(TokenType.Assign, "=", "=", 0, 0, 0, 0, "", _currentSyntaxLevel), value));
                    }
                    else
                    {
                        // Regular array element
                        elements.Add(ParseAssignment());
                    }
                } while (Match(TokenType.Comma));
            }
            
            Consume(TokenType.RightBrace, "Expected '}' after collection initializer.");
            Console.WriteLine($"DEBUG: Successfully parsed collection initializer with {elements.Count} elements");
            
            return new ArrayExpression(Previous(), elements);
        }

        private Expression ParseRangeOrExpression()
        {
            // Parse first part of potential range or comparison
            var left = ParseAddition();
            
            // Check for range operator
            if (Match(TokenType.Range))
            {
                var right = ParseAddition();
                // Create a range expression - for now, use a binary expression
                return new BinaryExpression(left, Previous(), right);
            }
            
            // Check for spread operator (inclusive range)
            if (Match(TokenType.Spread))
            {
                var right = ParseAddition();
                // Create a spread range expression - for now, use a binary expression
                return new BinaryExpression(left, Previous(), right);
            }
            
            // Check for spaceship operator (three-way comparison)
            if (Match(TokenType.Spaceship))
            {
                var right = ParseAddition();
                // Create a spaceship comparison expression
                return new BinaryExpression(left, Previous(), right);
            }
            
            // Check for null coalescing operator (??)
            if (Match(TokenType.NullCoalesce))
            {
                var right = ParseAddition();
                // Create a null coalescing expression
                return new BinaryExpression(left, Previous(), right);
            }
            
            // Check for null conditional operator (?.)
            if (Match(TokenType.NullConditional))
            {
                var member = Consume(TokenType.Identifier, "Expected member name after '?.'");
                // Create a null conditional member access expression
                return new MemberExpression(left, Previous(), member);
            }
            
            // Continue parsing as normal expression if no special operators
            return FinishExpression(left);
        }
        
        private Expression FinishExpression(Expression left)
        {
            // Check for match expression
            if (Match(TokenType.Match))
            {
                return ParseMatchExpression(left);
            }
            
            // For now, just return the left expression 
            // Range parsing is handled in ParseRangeOrExpression
            return left;
        }
        
        private Expression ParseMatchExpression(Expression target)
        {
            Consume(TokenType.LeftBrace, "Expected '{' after 'match'.");
            
            var arms = new List<MatchArm>();
            
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                // Parse match arm: pattern => expression
                var pattern = ParseMatchPattern();
                
                // Check for guard clause (when condition)
                Expression guard = null;
                if (Match(TokenType.When))
                {
                    guard = ParseAssignment();
                }
                
                Consume(TokenType.DoubleArrow, "Expected '=>' after pattern.");
                var expression = ParseAssignment();
                
                arms.Add(new MatchArm(pattern, guard, expression));
                
                // Optional comma between arms
                if (Check(TokenType.Comma))
                {
                    Advance();
                }
            }
            
            Consume(TokenType.RightBrace, "Expected '}' after match arms.");
            
            return new MatchExpression(target, arms);
        }
        
        private Pattern ParseMatchPattern()
        {
            // Handle wildcard pattern
            if (Match(TokenType.Underscore))
            {
                return new WildcardPattern();
            }
            
            // Handle tuple patterns
            if (Check(TokenType.LeftParen))
            {
                return ParseTupleMatchPattern();
            }
            
            // Handle literal patterns
            if (Check(TokenType.IntegerLiteral) || Check(TokenType.DoubleLiteral) || 
                Check(TokenType.StringLiteral) || Check(TokenType.BooleanLiteral))
            {
                var literal = ParsePrimary();
                return new LiteralPattern(literal);
            }
            
            // Handle identifier patterns (variable capture)
            if (Check(TokenType.Identifier))
            {
                var identifier = Advance();
                return new IdentifierPattern(identifier);
            }
            
            throw new ParseException($"Expected pattern at line {Current().Line}.");
        }
        
        private Pattern ParseTupleMatchPattern()
        {
            Consume(TokenType.LeftParen, "Expected '(' for tuple pattern.");
            
            var patterns = new List<Pattern>();
            
            if (!Check(TokenType.RightParen))
            {
                do
                {
                    patterns.Add(ParseMatchPattern());
                } while (Match(TokenType.Comma));
            }
            
            Consume(TokenType.RightParen, "Expected ')' after tuple pattern.");
            
            return new TupleMatchPattern(patterns);
        }

        #endregion

        #region Statement Parsing

        private Statement ParseStatement()
        {
            // Skip any attributes before the statement (for local type declarations)
            SkipAttributes();
            
            if (_currentSyntaxLevel == SyntaxLevel.High)
            {
                return ParseHighLevelStatement();
            }
            
            if (_currentSyntaxLevel == SyntaxLevel.Medium)
            {
                return ParseMediumLevelStatement();
            }
            
            if (_currentSyntaxLevel == SyntaxLevel.Low)
            {
                return ParseLowLevelStatement();
            }
            
            if (_currentSyntaxLevel == SyntaxLevel.Assembly)
            {
                // For assembly level, use low-level parsing which supports print statements
                // Real assembly blocks would be parsed by ParseAssemblyStatement
                return ParseLowLevelStatement();
            }
            
            // Control flow
            if (Match(TokenType.If)) return ParseIfStatement();
            if (Match(TokenType.While)) return ParseWhileStatement();
            if (Match(TokenType.For)) return ParseForStatement();
            if (Match(TokenType.ForEach)) return ParseForEachStatement();
            if (Match(TokenType.Do)) return ParseDoWhileStatement();
            if (Match(TokenType.Switch)) return ParseSwitchStatement();
            if (Match(TokenType.Match)) return ParseMatchStatement();

            // Custom loops
            if (Match(TokenType.Repeat)) return ParseRepeatStatement();
            if (Match(TokenType.Iterate)) return ParseIterateStatement();
            if (Match(TokenType.Forever)) return ParseForeverStatement();
            if (Match(TokenType.ParallelFor)) return ParseParallelForStatement();

            // Jump statements
            if (Match(TokenType.Return)) return ParseReturnStatement();
            if (Match(TokenType.Break)) return ParseBreakStatement();
            if (Match(TokenType.Continue)) return ParseContinueStatement();
            if (Match(TokenType.Throw)) return ParseThrowStatement();
            if (Match(TokenType.Yield)) return ParseYieldStatement();

            // Exception handling
            if (Match(TokenType.Try)) return ParseTryStatement();

            // Unsafe blocks
            if (Match(TokenType.Unsafe)) return ParseUnsafeStatement();
            
            // Fixed statement for pinning memory
            if (Match(TokenType.Fixed)) return ParseFixedStatement();

            // Resource management
            // Check if this is a using statement (with parentheses) or a using directive
            if (Check(TokenType.Using))
            {
                // Peek ahead to see if it's followed by '('
                if (PeekNext()?.Type == TokenType.LeftParen)
                {
                    // It's a using statement for resource management
                    Match(TokenType.Using);
                    return ParseUsingStatement();
                }
                else
                {
                    // It's a using directive, handle it here
                    Match(TokenType.Using);
                    return ParseUsing();
                }
            }
            if (Match(TokenType.Lock)) return ParseLockStatement();

            // Block
            if (Match(TokenType.LeftBrace)) return ParseBlock();

            // Assembly
            if (Match(TokenType.Assembly)) return ParseAssemblyStatement();

            // Check for type declarations inside methods (nested types)
            if (Match(TokenType.Class, TokenType.Interface, TokenType.Struct, TokenType.Enum))
            {
                var declType = Previous().Type;
                var modifiers = new List<Modifier>();  // Local types usually don't have modifiers
                
                switch (declType)
                {
                    case TokenType.Class:
                        // Handle class declarations properly
                        return ParseClass(modifiers);
                        
                    case TokenType.Interface:
                        // Handle interface declarations properly
                        return ParseInterface(modifiers);
                        
                    case TokenType.Enum:
                        // Handle enum declarations properly
                        return ParseEnum(modifiers);
                        
                    case TokenType.Struct:
                        // Handle struct declarations properly
                        return ParseStruct(modifiers);
                        
                    default:
                        throw Error(Current(), $"Local {declType} declarations are not supported yet.");
                }
            }

            // Var-inferred declaration using := syntax (e.g., numbers := [1,2,3])
            if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.Assign)
            {
                var nameToken = ConsumeIdentifier("Expected variable name.");
                Consume(TokenType.Assign, "Expected ':=' operator.");
                var initializerExpr = ParseExpression();

                // Optional semicolon for medium/low syntax levels
                if (Match(TokenType.Semicolon)) { /* consume */ }

                var varType = new TypeNode("var");
                return new VariableDeclaration(varType, nameToken, initializerExpr, false, false);
            }

            // Variable declaration or expression statement
            if (PeekType() != null)
            {
                // Save position to restore if this isn't a variable declaration
                var savedPosition = _current;
                
                try
                {
                    // Try to parse the full type (including array brackets, etc.)
                    var type = ParseType();
                    
                    // Now check if the next token is an identifier
                    if (Check(TokenType.Identifier) || Check(TokenType.Transform) || 
                        Check(TokenType.Data) || Check(TokenType.Component) || Check(TokenType.System) || Check(TokenType.Entity) ||
                        IsGreekLetterOrMathSymbol(Current().Type))
                    {
                        var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
                        return ParseVariableDeclaration(type, name);
                    }
                    else
                    {
                        // Not a variable declaration, restore position
                        _current = savedPosition;
                    }
                }
                catch
                {
                    // Failed to parse type, restore position
                    _current = savedPosition;
                }
            }

            var stmt = ParseExpressionStatement();

            return stmt;
        }

        private Statement ParseLowLevelStatement()
        {
            // Skip any attributes at the beginning of the statement
            SkipAttributes();
            
            // Handle print statements even in low-level syntax
            if (Check(TokenType.Print))
            {
                Advance(); // consume 'print'
                var expr = ParseExpression();
                
                // Convert print to Console.WriteLine
                var printCall = new CallExpression(
                    new IdentifierExpression(
                        new Token(TokenType.Identifier, "Console.WriteLine", null, 0, 0, 0, 0, "", _currentSyntaxLevel)),
                    new List<Expression> { expr });
                
                // Semicolon is optional in low-level syntax  
                Match(TokenType.Semicolon);
                
                return new ExpressionStatement(printCall);
            }

            // Handle struct declarations specifically to preserve syntax level
            if (Check(TokenType.Struct))
            {
                var modifiers = new List<Modifier>();
                Match(TokenType.Struct); // consume 'struct'
                return ParseStruct(modifiers);
            }

            // Handle union declarations
            if (Check(TokenType.Union))
            {
                var modifiers = new List<Modifier>();
                Match(TokenType.Union); // consume 'union'
                // For now, parse union as a struct (need to implement UnionDeclaration)
                // We've already consumed the union token, so ParseStruct will expect the name next
                return ParseStruct(modifiers);
            }

            // Handle unsafe blocks
            if (Match(TokenType.Unsafe))
            {
                return ParseUnsafeStatement();
            }
            
            // Handle return statements directly in low-level mode
            if (Check(TokenType.Return))
            {
                Advance(); // consume 'return'
                return ParseReturnStatement();
            }

            // Handle range-based for loops (for i in 0..10)
            if (Check(TokenType.For))
            {
                return ParseRangeBasedForLoop();
            }

            // Handle assembly blocks in low-level/assembly syntax
            if (Match(TokenType.Assembly)) return ParseAssemblyStatement();

            // Handle variable declarations in low-level mode - FIXED logic
            if (Check(TokenType.Var) || IsVariableDeclarationPattern())
            {
                if (Match(TokenType.Var))
                {
                    var name = ConsumeIdentifierOrGreekLetter("Expected variable name after 'var'.");
                    
                    TypeNode type;
                    if (Match(TokenType.Colon))
                    {
                        type = ParseType();
                    }
                    else
                    {
                        type = new TypeNode("var"); // Type inference
                    }
                    
                    return ParseVariableDeclaration(type, name);
                }
                else
                {
                    // Explicit type declaration (e.g., int x = 5;)
                    var type = ParseType();
                    var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
                    return ParseVariableDeclaration(type, name);
                }
            }

            // For other statements in low-level syntax, fall back to standard parsing
            // by temporarily switching to medium level
            var savedLevel = _currentSyntaxLevel;
            _currentSyntaxLevel = SyntaxLevel.Medium;
            var stmt = ParseStatement();
            _currentSyntaxLevel = savedLevel;
            return stmt;
        }

        private IfStatement ParseIfStatement()
        {
            // Support both traditional if (condition) and modern if condition syntax
            bool hasParens = Match(TokenType.LeftParen);
            var condition = ParseExpression();
            if (hasParens)
            {
                Consume(TokenType.RightParen, "Expected ')' after condition.");
            }

            var thenBranch = ParseStatement();
            Statement elseBranch = null;

            if (Match(TokenType.Else))
            {
                elseBranch = ParseStatement();
            }

            return new IfStatement(Previous(), condition, thenBranch, elseBranch);
        }

        private WhileStatement ParseWhileStatement()
        {
            var whileToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'while'.");
            var condition = ParseExpression();
            Consume(TokenType.RightParen, "Expected ')' after condition.");

            var body = ParseStatement();

            return new WhileStatement(whileToken, condition, body);
        }

        private ForStatement ParseForStatement()
        {
            var forToken = Previous();
            
            // Check for Rust-style for loop: "for i in range"
            if (Check(TokenType.Identifier) && PeekNext() != null && PeekNext().Type == TokenType.In)
            {
                // Parse as range-based for loop
                var iteratorName = ConsumeIdentifierOrGreekLetter("Expected iterator variable name.");
                Consume(TokenType.In, "Expected 'in' after iterator variable.");
                var rangeExpression = ParseExpression(); // Parse the range (e.g., 0..a.len())
                
                var rangeBody = ParseStatement();
                
                // Convert range-based for loop to foreach statement
                var iteratorType = new TypeNode("int"); // Assume int type for range iteration
                var forEach = new ForEachStatement(forToken, iteratorType, iteratorName, rangeExpression, rangeBody);
                
                // For now, return a ForStatement that wraps the ForEach behavior
                // In a full implementation, we'd have proper range iteration support
                var init = new VariableDeclaration(iteratorType, iteratorName, null, false, false);
                return new ForStatement(forToken, init, null, null, rangeBody);
            }
            
            // Traditional C-style for loop
            Consume(TokenType.LeftParen, "Expected '(' after 'for'.");

            Statement initializer = null;
            if (!Check(TokenType.Semicolon))
            {
                if (PeekType() != null)
                {
                    var type = ParseType();
                    var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
                    initializer = ParseVariableDeclaration(type, name);
                }
                else
                {
                    initializer = new ExpressionStatement(ParseExpression());
                    Consume(TokenType.Semicolon, "Expected ';' after loop initializer.");
                }
            }
            else
            {
                Consume(TokenType.Semicolon, "Expected ';'.");
            }

            Expression condition = null;
            if (!Check(TokenType.Semicolon))
            {
                condition = ParseExpression();
            }
            Consume(TokenType.Semicolon, "Expected ';' after loop condition.");

            Expression update = null;
            if (!Check(TokenType.RightParen))
            {
                update = ParseExpression();
            }
            Consume(TokenType.RightParen, "Expected ')' after for clauses.");

            var body = ParseStatement();

            return new ForStatement(forToken, initializer, condition, update, body);
        }

        private ForEachStatement ParseForEachStatement()
        {
            var forEachToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'foreach'.");

            var elementType = ParseType();
            var elementName = ConsumeIdentifierOrGreekLetter("Expected element name.");
            Consume(TokenType.In, "Expected 'in' in foreach loop.");
            var collection = ParseExpression();

            Consume(TokenType.RightParen, "Expected ')' after foreach header.");

            var body = ParseStatement();

            return new ForEachStatement(forEachToken, elementType, elementName, collection, body);
        }

        private RepeatStatement ParseRepeatStatement()
        {
            var repeatToken = Previous();

            Expression count = null;
            if (Match(TokenType.LeftParen))
            {
                count = ParseExpression();
                Consume(TokenType.RightParen, "Expected ')' after repeat count.");
            }

            var body = ParseStatement();

            return new RepeatStatement(repeatToken, count, body);
        }

        private IterateStatement ParseIterateStatement()
        {
            var iterateToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'iterate'.");

            var iteratorName = Consume(TokenType.Identifier, "Expected iterator name.").Lexeme;
            Consume(TokenType.Colon, "Expected ':' after iterator name.");

            var start = ParseExpression();
            Consume(TokenType.Range, "Expected '..' in iterate statement.");
            var end = ParseExpression();

            Expression step = new LiteralExpression(new Token(TokenType.IntegerLiteral, "1", 1, 0, 0, 0, 0, "", _currentSyntaxLevel));
            if (Match(TokenType.Colon))
            {
                step = ParseExpression();
            }

            Consume(TokenType.RightParen, "Expected ')' after iterate header.");

            var body = ParseStatement();

            return new IterateStatement(iterateToken, iteratorName, start, end, step, body);
        }

        private Statement ParseForeverStatement()
        {
            var body = ParseStatement();
            
            // Forever loop is just while(true)
            var trueLiteral = new LiteralExpression(new Token(TokenType.BooleanLiteral, "true", true, 0, 0, 0, 0, "", _currentSyntaxLevel));
            return new WhileStatement(Previous(), trueLiteral, body);
        }

        private ParallelForStatement ParseParallelForStatement()
        {
            var parallelToken = Previous();
            
            int? maxParallelism = null;
            if (Match(TokenType.LeftBracket))
            {
                var parallelismExpr = ParseExpression();
                // In a real implementation, we'd evaluate this at compile time
                Consume(TokenType.RightBracket, "Expected ']' after parallelism degree.");
            }

            Consume(TokenType.For, "Expected 'for' after 'parallel'.");
            var baseFor = ParseForStatement();

            return new ParallelForStatement(parallelToken, baseFor, maxParallelism);
        }

        private MatchStatement ParseMatchStatement()
        {
            var matchToken = Previous();
            var expression = ParseExpression();
            
            Consume(TokenType.LeftBrace, "Expected '{' before match cases.");

            var cases = new List<MatchCase>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                cases.Add(ParseMatchCase());
            }

            Consume(TokenType.RightBrace, "Expected '}' after match cases.");

            return new MatchStatement(matchToken, expression, cases);
        }

        private MatchCase ParseMatchCase()
        {
            var pattern = ParsePattern();
            
            Expression guard = null;
            if (Match(TokenType.When))
            {
                guard = ParseExpression();
            }

            Consume(TokenType.DoubleArrow, "Expected '=>' after pattern.");
            var body = ParseStatement();

            return new MatchCase(pattern, guard, body);
        }

        private Pattern ParsePattern()
        {
            // Simplified pattern parsing - in a real implementation this would be more complex
            return new ConstantPattern(ParseExpression());
        }

        private AssemblyStatement ParseAssemblyStatement()
        {
            var asmToken = Previous();
            Consume(TokenType.LeftBrace, "Expected '{' after 'asm'.");

            var assemblyCode = "";
            // In a real implementation, we'd properly parse assembly code
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                assemblyCode += Current().Lexeme + " ";
                Advance();
            }

            Consume(TokenType.RightBrace, "Expected '}' after assembly code.");

            return new AssemblyStatement(asmToken, assemblyCode.Trim());
        }

        private BlockStatement ParseBlock()
        {
            var statements = new List<Statement>();

            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                statements.Add(ParseStatement());
            }

            Consume(TokenType.RightBrace, "Expected '}' after block.");

            return new BlockStatement(statements);
        }

        private VariableDeclaration ParseVariableDeclaration(TypeNode type, Token name)
        {
            Expression memoryAddress = null;
            
            // Handle memory-mapped I/O with 'at' clause for embedded systems
            if (Match(TokenType.At))
            {
                memoryAddress = ParseExpression(); // Parse the memory address (e.g., 0x4000_0000)
            }
            
            Expression initializer = null;
            if (Match(TokenType.Assign))
            {
                // Array initializers can use braces regardless of whether explicitly new int[] or just {}
                if (Check(TokenType.LeftBrace))
                {
                    Match(TokenType.LeftBrace);
                    var elements = new List<Expression>();
                    
                    if (!Check(TokenType.RightBrace))
                    {
                        do
                        {
                            elements.Add(ParseExpression());
                        } while (Match(TokenType.Comma));
                    }
                    
                    Consume(TokenType.RightBrace, "Expected '}' after array initializer.");
                    
                    // Create an array expression from the elements
                    initializer = new ArrayExpression(Previous(), elements);
                }
                else
                {
                    initializer = ParseExpression();
                }
            }

            Consume(TokenType.Semicolon, "Expected ';' after variable declaration.");

            bool isConst = type.Name == "const";
            bool isReadonly = type.Name == "readonly";

            // For now, we'll store the memory address as the initializer if no other initializer is provided
            // In a full implementation, this would be handled specially by the compiler/linker
            if (memoryAddress != null && initializer == null)
            {
                // Create a special expression to represent memory-mapped variables
                // This could be handled by the compiler to generate appropriate linker directives
                initializer = memoryAddress;
            }

            return new VariableDeclaration(type, name, initializer, isConst, isReadonly);
        }

        private ExpressionStatement ParseExpressionStatement()
        {
            var expr = ParseExpression();
            Consume(TokenType.Semicolon, "Expected ';' after expression.");
            return new ExpressionStatement(expr);
        }

        private ReturnStatement ParseReturnStatement()
        {
            var returnToken = Previous();
            Expression value = null;

            if (!Check(TokenType.Semicolon))
            {
                value = ParseExpression();
            }

            Consume(TokenType.Semicolon, "Expected ';' after return value.");
            return new ReturnStatement(returnToken, value);
        }

        private BreakStatement ParseBreakStatement()
        {
            var breakToken = Previous();
            Consume(TokenType.Semicolon, "Expected ';' after 'break'.");
            return new BreakStatement(breakToken);
        }

        private ContinueStatement ParseContinueStatement()
        {
            var continueToken = Previous();
            Consume(TokenType.Semicolon, "Expected ';' after 'continue'.");
            return new ContinueStatement(continueToken);
        }

        private ThrowStatement ParseThrowStatement()
        {
            var throwToken = Previous();
            var exception = ParseExpression();
            Consume(TokenType.Semicolon, "Expected ';' after throw expression.");
            return new ThrowStatement(throwToken, exception);
        }

        private YieldStatement ParseYieldStatement()
        {
            var yieldToken = Previous();
            
            if (Match(TokenType.Break))
            {
                Consume(TokenType.Semicolon, "Expected ';' after 'yield break'.");
                return new YieldStatement(yieldToken, null, true);
            }

            var value = ParseExpression();
            Consume(TokenType.Semicolon, "Expected ';' after yield value.");
            return new YieldStatement(yieldToken, value, false);
        }

        private TryStatement ParseTryStatement()
        {
            var tryToken = Previous();
            Consume(TokenType.LeftBrace, "Expected '{' after 'try'.");
            var tryBlock = ParseBlock();

            var catchClauses = new List<CatchClause>();
            while (Match(TokenType.Catch))
            {
                TypeNode exceptionType = null;
                string exceptionName = null;

                if (Match(TokenType.LeftParen))
                {
                    exceptionType = ParseType();
                    exceptionName = ConsumeIdentifierOrGreekLetter("Expected exception variable name.").Lexeme;
                    Consume(TokenType.RightParen, "Expected ')' after catch clause.");
                }

                // Check for optional when clause (exception filters)
                Expression whenCondition = null;
                if (Match(TokenType.When))
                {
                    Consume(TokenType.LeftParen, "Expected '(' after 'when'.");
                    whenCondition = ParseExpression();
                    Consume(TokenType.RightParen, "Expected ')' after when condition.");
                }

                Consume(TokenType.LeftBrace, "Expected '{' after catch clause.");
                var catchBody = ParseBlock();
                catchClauses.Add(new CatchClause(exceptionType, exceptionName, catchBody, whenCondition));
            }

            Statement finallyBlock = null;
            if (Match(TokenType.Finally))
            {
                Consume(TokenType.LeftBrace, "Expected '{' after 'finally'.");
                finallyBlock = ParseBlock();
            }

            return new TryStatement(tryToken, tryBlock, catchClauses, finallyBlock);
        }

        private UnsafeStatement ParseUnsafeStatement()
        {
            var unsafeToken = Previous();
            Consume(TokenType.LeftBrace, "Expected '{' after 'unsafe'.");
            
            // Parse block statements in low-level mode to ensure proper context
            var statements = new List<Statement>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                statements.Add(ParseLowLevelStatement());
            }
            Consume(TokenType.RightBrace, "Expected '}' after block.");
            var body = new BlockStatement(statements);
            
            return new UnsafeStatement(unsafeToken, body);
        }
        
        private ForEachStatement ParseRangeBasedForLoop()
        {
            var forToken = Advance(); // consume 'for'
            var iteratorName = ConsumeIdentifierOrGreekLetter("Expected iterator variable name.");
            Consume(TokenType.In, "Expected 'in' after iterator variable.");
            var rangeExpression = ParseExpression(); // Parse the range (e.g., 0..256)
            
            Consume(TokenType.LeftBrace, "Expected '{' after range expression.");
            
            // Parse block statements in low-level mode to ensure proper context
            var statements = new List<Statement>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                statements.Add(ParseLowLevelStatement());
            }
            Consume(TokenType.RightBrace, "Expected '}' after block.");
            var body = new BlockStatement(statements);
            
            // Convert range-based for loop to foreach statement
            // This treats the range as a collection to iterate over
            var iteratorType = new TypeNode("int"); // Assume int type for range iteration
            return new ForEachStatement(forToken, iteratorType, iteratorName, rangeExpression, body);
        }
        
        private FixedStatement ParseFixedStatement()
        {
            var fixedToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'fixed'.");
            
            // Parse the type (which may include pointer)
            var type = ParseType();
            
            // Parse the variable name
            var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
            
            Consume(TokenType.Assign, "Expected '=' in fixed statement.");
            
            // Parse the target expression
            var target = ParseExpression();
            
            Consume(TokenType.RightParen, "Expected ')' after fixed declaration.");
            
            // Parse the body statement or block
            var body = ParseStatement();
            
            return new FixedStatement(fixedToken, type, name, target, body);
        }

        private UsingStatement ParseUsingStatement()
        {
            var usingToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'using'.");

            var type = ParseType();
            var name = ConsumeIdentifierOrGreekLetter("Expected variable name.");
            var resource = ParseVariableDeclaration(type, name);

            Consume(TokenType.RightParen, "Expected ')' after using resource.");

            var body = ParseStatement();

            return new UsingStatement(usingToken, resource, body);
        }

        private LockStatement ParseLockStatement()
        {
            var lockToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'lock'.");
            var lockObject = ParseExpression();
            Consume(TokenType.RightParen, "Expected ')' after lock object.");

            var body = ParseStatement();

            return new LockStatement(lockToken, lockObject, body);
        }

        private DoWhileStatement ParseDoWhileStatement()
        {
            var doToken = Previous();
            var body = ParseStatement();
            Consume(TokenType.While, "Expected 'while' after do body.");
            Consume(TokenType.LeftParen, "Expected '(' after 'while'.");
            var condition = ParseExpression();
            Consume(TokenType.RightParen, "Expected ')' after condition.");
            Consume(TokenType.Semicolon, "Expected ';' after do-while.");

            return new DoWhileStatement(doToken, body, condition);
        }

        private SwitchStatement ParseSwitchStatement()
        {
            var switchToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'switch'.");
            var expression = ParseExpression();
            Consume(TokenType.RightParen, "Expected ')' after switch expression.");
            Consume(TokenType.LeftBrace, "Expected '{' before switch body.");

            var cases = new List<CaseClause>();
            Statement defaultCase = null;

            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                if (Match(TokenType.Case))
                {
                    var value = ParseExpression();
                    Consume(TokenType.Colon, "Expected ':' after case value.");
                    
                    var statements = new List<Statement>();
                    while (!Check(TokenType.Case) && !Check(TokenType.Default) && 
                           !Check(TokenType.RightBrace) && !IsAtEnd())
                    {
                        statements.Add(ParseStatement());
                    }

                    cases.Add(new CaseClause(value, statements));
                }
                else if (Match(TokenType.Default))
                {
                    Consume(TokenType.Colon, "Expected ':' after 'default'.");
                    
                    var statements = new List<Statement>();
                    while (!Check(TokenType.Case) && !Check(TokenType.Default) && 
                           !Check(TokenType.RightBrace) && !IsAtEnd())
                    {
                        statements.Add(ParseStatement());
                    }

                    defaultCase = new BlockStatement(statements);
                }
                else
                {
                    throw Error(Current(), "Expected 'case' or 'default' in switch body.");
                }
            }

            Consume(TokenType.RightBrace, "Expected '}' after switch body.");

            return new SwitchStatement(switchToken, expression, cases, defaultCase);
        }

        private NamespaceDeclaration ParseNamespace()
        {
            var namespaceName = "";
            do
            {
                var part = Consume(TokenType.Identifier, "Expected namespace name.");
                namespaceName += part.Lexeme;
                if (Match(TokenType.Dot))
                {
                    namespaceName += ".";
                }
                else
                {
                    break;
                }
            } while (true);

            Consume(TokenType.LeftBrace, "Expected '{' before namespace body.");

            var members = new List<Statement>();
            while (!Check(TokenType.RightBrace) && !IsAtEnd())
            {
                members.Add(ParseDeclaration());
            }

            Consume(TokenType.RightBrace, "Expected '}' after namespace body.");

            return new NamespaceDeclaration(Previous(), namespaceName, members);
        }

        private ImportDeclaration ParseImport()
        {
            var importToken = Previous();
            var modulePath = "";
            
            do
            {
                var part = Consume(TokenType.Identifier, "Expected module name.");
                modulePath += part.Lexeme;
                if (Match(TokenType.Dot))
                {
                    modulePath += ".";
                }
                else
                {
                    break;
                }
            } while (true);

            string alias = null;
            if (Match(TokenType.As))
            {
                alias = Consume(TokenType.Identifier, "Expected alias name.").Lexeme;
            }

            var importedNames = new List<string>();
            if (Match(TokenType.LeftBrace))
            {
                do
                {
                    importedNames.Add(Consume(TokenType.Identifier, "Expected import name.").Lexeme);
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.RightBrace, "Expected '}' after import list.");
            }

            Consume(TokenType.Semicolon, "Expected ';' after import.");

            return new ImportDeclaration(importToken, modulePath, alias, importedNames);
        }

        private Statement ParseUsing()
        {
            // Could be using statement or using directive
            if (Check(TokenType.LeftParen))
            {
                return ParseUsingStatement();
            }

            // Using directive
            // Note: "using" was already consumed by ParseDeclaration
            var usingToken = _tokens[_current - 1]; // Get the "using" token
            bool isStatic = false;
            
            // Check for "using static" - must be done before parsing namespace
            if (Check(TokenType.Static))
            {
                isStatic = true;
                Advance(); // Consume "static"
            }
            
            var namespacePath = "";
            
            do
            {
                var part = Consume(TokenType.Identifier, "Expected namespace name.");
                namespacePath += part.Lexeme;
                if (Match(TokenType.Dot))
                {
                    namespacePath += ".";
                }
                else
                {
                    break;
                }
            } while (true);

            Consume(TokenType.Semicolon, "Expected ';' after using directive.");

            // Pass isStatic flag to ImportDeclaration
            return new ImportDeclaration(usingToken, namespacePath, null, null, isStatic);
        }

        private TypeAliasDeclaration ParseTypeAlias()
        {
            var aliasToken = Previous();
            var name = Consume(TokenType.Identifier, "Expected alias name.");
            Consume(TokenType.Assign, "Expected '=' in type alias.");
            var type = ParseType();
            Consume(TokenType.Semicolon, "Expected ';' after type alias.");

            return new TypeAliasDeclaration(aliasToken, name, type);
        }

        #endregion

        #region Expression Parsing

        private Expression ParseExpression()
        {
            return ParseAssignment(); // Fixed: assignments have lowest precedence, should be parsed first
        }
        
        private Expression ParseAssignment()
        {
            // Check for lambda expressions first before parsing other expressions
            // This is needed because lambda expressions have lower precedence than most operators
            if (IsLambdaStart())
            {
                return ParseLambdaExpression();
            }
            
            var expr = ParseTernary();
            
            if (Match(TokenType.Assign, TokenType.PlusAssign, TokenType.MinusAssign,
                     TokenType.MultiplyAssign, TokenType.DivideAssign, TokenType.ModuloAssign,
                     TokenType.BitwiseAndAssign, TokenType.BitwiseOrAssign, TokenType.BitwiseXorAssign,
                     TokenType.LeftShiftAssign, TokenType.RightShiftAssign,
                     TokenType.NullCoalesceAssign, TokenType.PowerAssign))
            {
                var op = Previous();
                var value = ParseAssignment(); // right-associative

                // Valid assignment targets: identifier, member access, indexed access, or pointer dereference
                if (expr is IdentifierExpression || expr is MemberExpression || expr is BinaryExpression || expr is UnaryExpression)
                {
                    return new AssignmentExpression(expr, op, value);
                }

                throw Error(op, "Invalid assignment target.");
            }
            
            return expr;
        }

        private Expression ParseTernary()
        {
            var expr = ParseNullCoalescing();

            if (Match(TokenType.Question))
            {
                var trueExpr = ParseExpression();
                Consume(TokenType.Colon, "Expected ':' in ternary expression.");
                var falseExpr = ParseExpression();
                return new ConditionalExpression(expr, trueExpr, falseExpr);
            }

            return expr;
        }

        private Expression ParseNullCoalescing()
        {
            var expr = ParseConditionalAccess();

            while (Match(TokenType.NullCoalesce))
            {
                var op = Previous();
                var right = ParseConditionalAccess();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseConditionalAccess()
        {
            var expr = ParseLogicalOr();

            // Handle null-conditional operations at higher precedence than null-coalescing
            while (Match(TokenType.NullConditional))
            {
                var op = Previous();
                
                // Parse member access or method call after ?.
                if (Check(TokenType.Identifier))
                {
                    var name = ConsumeIdentifierOrGreekLetter("Expected property name after '?.'.");
                    expr = new MemberExpression(expr, op, name);
                    
                    // Handle method calls like obj?.Method()
                    if (Match(TokenType.LeftParen))
                    {
                        expr = FinishCall(expr);
                    }
                }
                else
                {
                    throw Error(Current(), "Expected property or method name after '?.'.");
                }
            }

            return expr;
        }

        private Expression ParseLogicalOr()
        {
            var expr = ParseLogicalAnd();

            while (Match(TokenType.LogicalOr))
            {
                var op = Previous();
                var right = ParseLogicalAnd();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseLogicalAnd()
        {
            var expr = ParseBitwiseOr();

            while (Match(TokenType.LogicalAnd))
            {
                var op = Previous();
                var right = ParseBitwiseOr();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseBitwiseOr()
        {
            var expr = ParseBitwiseXor();

            while (Match(TokenType.BitwiseOr, TokenType.Union))
            {
                var op = Previous();
                var right = ParseBitwiseXor();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseBitwiseXor()
        {
            var expr = ParseBitwiseAnd();

            while (Match(TokenType.BitwiseXor))
            {
                var op = Previous();
                var right = ParseBitwiseAnd();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseBitwiseAnd()
        {
            var expr = ParseEquality();

            while (Match(TokenType.BitwiseAnd, TokenType.Intersection))
            {
                var op = Previous();
                var right = ParseEquality();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseEquality()
        {
            var expr = ParseComparison();

            while (Match(TokenType.Equal, TokenType.NotEqual, TokenType.NotEqual2,
                        TokenType.Element, TokenType.NotElement, TokenType.Identical, 
                        TokenType.NotIdentical, TokenType.Almost, TokenType.NotAlmost))
            {
                var op = Previous();
                var right = ParseComparison();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseComparison()
        {
            var expr = ParseRange();

            // In high-level syntax, don't consume 'is' as a comparison operator
            // because it's used for natural language comparisons like "is greater than"
            var comparisonTypes = _currentSyntaxLevel == SyntaxLevel.High
                ? new[] { TokenType.Greater, TokenType.GreaterEqual, TokenType.Less, 
                         TokenType.LessEqual, TokenType.LessOrEqual, TokenType.GreaterOrEqual,
                         TokenType.Spaceship }
                : new[] { TokenType.Greater, TokenType.GreaterEqual, TokenType.Less, 
                         TokenType.LessEqual, TokenType.LessOrEqual, TokenType.GreaterOrEqual,
                         TokenType.Spaceship, TokenType.Is };

            while (Match(comparisonTypes))
            {
                var op = Previous();
                
                // Handle 'is' pattern matching specially
                if (op.Type == TokenType.Is && _currentSyntaxLevel != SyntaxLevel.High)
                {
                    // Check if this is pattern matching (type test with optional variable declaration)
                    var savedPosition = _current;
                    
                    // Try to parse a type
                    if (PeekType() != null)
                    {
                        var type = ParseType();
                        
                        // Check if there's a variable declaration after the type
                        Token variable = null;
                        if (Check(TokenType.Identifier))
                        {
                            variable = Advance();
                        }
                        
                        expr = new IsExpression(expr, op, type, variable);
                    }
                    else
                    {
                        // Not pattern matching, treat as regular comparison
                        _current = savedPosition;
                var right = ParseRange();
                expr = new BinaryExpression(expr, op, right);
                    }
                }
                else
                {
                    var right = ParseRange();
                    expr = new BinaryExpression(expr, op, right);
                }
            }

            return expr;
        }

        private Expression ParseRange()
        {
            var expr = ParseShift();
            
            // Check for range operators
            if (Match(TokenType.Range))
            {
                var right = ParseShift();
                return new BinaryExpression(expr, Previous(), right);
            }
            
            // Check for spread operator (inclusive range)
            if (Match(TokenType.Spread))
            {
                var right = ParseShift();
                return new BinaryExpression(expr, Previous(), right);
            }
            
            return expr;
        }

        private Expression ParseShift()
        {
            var expr = ParseAddition();

            while (Match(TokenType.LeftShift, TokenType.RightShift, TokenType.UnsignedRightShift))
            {
                var op = Previous();
                var right = ParseAddition();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseAddition()
        {
            var expr = ParseMultiplication();

            while (Match(TokenType.Plus, TokenType.Minus))
            {
                var op = Previous();
                var right = ParseMultiplication();
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseMultiplication()
        {
            var expr = ParsePower();
            Console.WriteLine($"DEBUG: ParseMultiplication() starting with {expr} at token {Current().Type} '{Current().Lexeme}'");

            // Handle both explicit and implicit multiplication in a loop
            while (true)
            {
                // First check for explicit multiplication operators
                if (Match(TokenType.Multiply, TokenType.Divide, TokenType.Modulo, 
                         TokenType.IntegerDivide, TokenType.Times, TokenType.DivisionSign))
                {
                    var op = Previous();
                    Console.WriteLine($"DEBUG: ParseMultiplication() found operator {op.Type} '{op.Lexeme}'");
                    var right = ParsePower();
                    Console.WriteLine($"DEBUG: ParseMultiplication() parsed right operand: {right}");
                    expr = new BinaryExpression(expr, op, right);
                    continue; // Continue the loop to check for more operators
                }
                
                // Then check for implicit multiplication: number followed by identifier/constant
                // Examples: 4π, 2x, 3.14e (but only for literal expressions)
                if (expr is LiteralExpression literal && 
                    (Check(TokenType.Identifier) || Check(TokenType.Pi) || Check(TokenType.Tau) || 
                     Check(TokenType.Epsilon) || IsGreekLetterOrMathSymbol(Current().Type)))
                {
                    Console.WriteLine($"DEBUG: ParseMultiplication() detecting implicit multiplication between {literal.Value} and {Current().Type} '{Current().Lexeme}'");
                    // Create an implicit multiplication
                    var mathConstant = ParsePower(); // Parse the mathematical constant
                    var multiplyToken = new Token(TokenType.Multiply, "*", "*", 
                        Current().Line, Current().Column, Current().StartPosition, Current().EndPosition,
                        Current().FileName, Current().SyntaxLevel);
                    expr = new BinaryExpression(expr, multiplyToken, mathConstant);
                    continue; // Continue the loop to check for more operators after the implicit multiplication
                }
                
                // No more multiplication operations, break the loop
                break;
            }

            Console.WriteLine($"DEBUG: ParseMultiplication() completed with result: {expr}");
            return expr;
        }

        private Expression ParsePower()
        {
            var expr = ParseUnary();

            if (Match(TokenType.Power))
            {
                var op = Previous();
                var right = ParsePower(); // Right associative
                expr = new BinaryExpression(expr, op, right);
            }

            return expr;
        }

        private Expression ParseUnary()
        {
            if (Match(TokenType.LogicalNot, TokenType.BitwiseNot, TokenType.Plus, TokenType.Minus,
                     TokenType.Increment, TokenType.Decrement, TokenType.Typeof, TokenType.Sizeof,
                     TokenType.Nameof, TokenType.New, TokenType.Delete, TokenType.Multiply, TokenType.BitwiseAnd))
            {
                var op = Previous();
                
                if (op.Type == TokenType.Typeof)
                {
                    var type = ParseType();
                    return new TypeofExpression(op, type);
                }
                else if (op.Type == TokenType.Sizeof)
                {
                    var type = ParseType();
                    return new SizeofExpression(op, type);
                }
                else if (op.Type == TokenType.Nameof)
                {
                    var expr = ParseExpression();
                    return new NameofExpression(op, expr);
                }
                else if (op.Type == TokenType.New)
                {
                    return ParseNewExpression(op);
                }
                else if (op.Type == TokenType.BitwiseAnd)
                {
                    // Special handling for reference expressions: &expr and &mut expr
                    // Check if this is &mut pattern
                    bool isMutable = false;
                    if (Check(TokenType.Identifier) && Current().Lexeme == "mut")
                    {
                        Advance(); // consume 'mut'
                        isMutable = true;
                    }
                    
                    // Parse the expression after & or &mut
                    var expr = ParseUnary();
                    
                    // Create a reference expression - using UnaryExpression with special marker
                    // In a full implementation, you might want a dedicated ReferenceExpression AST node
                    return new UnaryExpression(op, expr, true);
                }
                else
                {
                    var expr = ParseUnary();
                    return new UnaryExpression(op, expr, true);
                }
            }

            return ParsePostfix();
        }

        private Expression ParsePostfix()
        {
            var expr = ParseCall();

            while (true)
            {
                if (Match(TokenType.Increment, TokenType.Decrement))
                {
                    var op = Previous();
                    expr = new UnaryExpression(op, expr, false);
                }
                else if (Match(TokenType.As))
                {
                    // Handle cast expression: expr as type
                    var asToken = Previous();
                    var targetType = ParseType();
                    expr = new CastExpression(asToken, targetType, expr);
                }
                else
                {
                    break;
                }
            }

            return expr;
        }

        private Expression ParseCall()
        {
            var expr = ParsePrimary();

            while (true)
            {
                if (Match(TokenType.LeftParen))
                {
                    expr = FinishCall(expr);
                }
                else if (Match(TokenType.Dot, TokenType.Arrow))
                {
                    var op = Previous();
                    var name = ConsumeIdentifierOrGreekLetter("Expected property name after '.'.");
                    expr = new MemberExpression(expr, op, name);
                }
                else if (Match(TokenType.LeftBracket))
                {
                    var index = ParseExpression();
                    Consume(TokenType.RightBracket, "Expected ']' after index.");
                    // Create array access expression
                    expr = new BinaryExpression(expr, Previous(), index);
                }
                else if (Match(TokenType.Match))
                {
                    // Handle match expressions: expr match { ... }
                    expr = ParseMatchExpression(expr);
                }
                else if (Check(TokenType.LeftBrace) && expr is IdentifierExpression)
                {
                    // Handle struct literal syntax: TypeName { field1, field2, ... }
                    Match(TokenType.LeftBrace);
                    var elements = new List<Expression>();
                    
                    if (!Check(TokenType.RightBrace))
                    {
                        do
                        {
                            // Handle both object initializer and collection initializer syntax
                            if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.Assign)
                            {
                                // Object initializer: field = value
                                var memberName = Consume(TokenType.Identifier, "Expected member name.");
                                Consume(TokenType.Assign, "Expected '=' in struct initializer.");
                                var value = ParseExpression();
                                
                                // Create member assignment for object initializer
                                var memberExpr = new IdentifierExpression(memberName);
                                var assignment = new AssignmentExpression(memberExpr, Previous(), value);
                                elements.Add(assignment);
                            }
                            else
                            {
                                // Collection/struct initializer: just values
                                elements.Add(ParseExpression());
                            }
                        } while (Match(TokenType.Comma));
                    }
                    
                    Consume(TokenType.RightBrace, "Expected '}' after struct literal.");
                    
                    // Create a struct literal expression - use NewExpression since it represents object creation
                    var identExpr = expr as IdentifierExpression;
                    var typeName = identExpr.Name;
                    var type = new TypeNode(typeName);
                    var emptyArgs = new List<Expression>();
                    
                    expr = new NewExpression(identExpr.Token, type, emptyArgs, elements);
                }
                else
                {
                    break;
                }
            }

            return expr;
        }

        private Expression FinishCall(Expression callee)
        {
            var arguments = new List<Expression>();

            if (!Check(TokenType.RightParen))
            {
                do
                {
                    // Enhanced argument parsing that properly handles lambda expressions
                    // Check if this looks like a lambda expression start
                    if (IsLambdaStart())
                    {
                        // Parse lambda expression specifically to avoid operator precedence issues
                        arguments.Add(ParseLambdaExpression());
                    }
                    else
                    {
                        // Parse regular expression
                        arguments.Add(ParseAssignment());
                    }
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.RightParen, "Expected ')' after arguments.");

            return new CallExpression(callee, arguments);
        }
        
        private bool IsLambdaStart()
        {
            // Save current position
            var savedPosition = _current;
            
            // Check for single parameter lambda: identifier =>
            if (Check(TokenType.Identifier))
            {
                Advance();
                bool isLambda = Check(TokenType.DoubleArrow);
                _current = savedPosition;
                return isLambda;
            }
            
            // Check for multi-parameter lambda: (param1, param2) =>
            if (Check(TokenType.LeftParen))
            {
                Advance();
                // Skip parameters
                int parenCount = 1;
                while (!IsAtEnd() && parenCount > 0)
                {
                    if (Check(TokenType.LeftParen)) parenCount++;
                    else if (Check(TokenType.RightParen)) parenCount--;
                    Advance();
                }
                
                bool isLambda = Check(TokenType.DoubleArrow);
                _current = savedPosition;
                return isLambda;
            }
            
            return false;
        }
        
        private Expression ParseLambdaExpression()
        {
            var parameters = new List<Parameter>();
            
            if (Check(TokenType.LeftParen))
            {
                Match(TokenType.LeftParen);
                // Multiple parameters or typed parameters
                if (!Check(TokenType.RightParen))
                {
                    do
                    {
                        // Try to parse a type, but if it fails, assume var
                        TypeNode type;
                        string name;
                        
                        // Check if this looks like a typed parameter (Type Identifier)
                        if (IsKnownTypeName(Current()) && PeekNext()?.Type == TokenType.Identifier)
                        {
                            // Typed parameter: int x, string y, etc.
                            type = ParseType();
                            name = Consume(TokenType.Identifier, "Expected parameter name.").Lexeme;
                        }
                        else
                        {
                            // Just an identifier, assume var type: x, y, etc.
                            var nameToken = ConsumeIdentifierOrGreekLetter("Expected parameter name.");
                            name = nameToken.Lexeme;
                            type = new TypeNode("var");
                        }
                        
                        parameters.Add(new Parameter(type, name));
                    } while (Match(TokenType.Comma));
                }
                
                Consume(TokenType.RightParen, "Expected ')' after parameters.");
            }
            else
            {
                // Single parameter without parentheses
                var name = Consume(TokenType.Identifier, "Expected parameter name.");
                parameters.Add(new Parameter(new TypeNode("var"), name.Lexeme));
            }
            
            Consume(TokenType.DoubleArrow, "Expected '=>' in lambda expression.");
            
            AstNode body;
            if (Check(TokenType.LeftBrace))
            {
                body = ParseBlock();
            }
            else
            {
                // Parse the full expression for lambda body, ensuring we get complete expressions
                body = ParseAssignment(); // Use assignment level to get full expression precedence
            }
            
            return new LambdaExpression(parameters, body);
        }

        private Expression ParseNewExpression(Token newToken)
        {
            // For array creation syntax like "new int[5]", we need to parse the base type
            // without consuming array brackets, since those are part of the creation syntax
            
            // Save current position to potentially backtrack
            var savedPosition = _current;
            
            // First, try to parse a simple type (not an array type)
            string typeName;
            
            if (Match(TokenType.Void, TokenType.Bool, TokenType.Byte, TokenType.SByte,
                     TokenType.Short, TokenType.UShort, TokenType.Int, TokenType.UInt,
                     TokenType.Long, TokenType.ULong, TokenType.Float, TokenType.Double,
                     TokenType.Decimal, TokenType.Char, TokenType.String, TokenType.Object,
                     TokenType.Dynamic, TokenType.Var))
            {
                typeName = Previous().Type.ToString().ToLower();
            }
            else if (Match(TokenType.Vector, TokenType.Matrix, TokenType.Quaternion, TokenType.Transform))
            {
                typeName = Previous().Lexeme;
            }
            else if (Match(TokenType.Identifier) || Match(TokenType.Transform))
            {
                typeName = Previous().Lexeme;
            }
            else
            {
                throw Error(Current(), $"Expected type name after 'new', but found {Current().Type} '{Current().Lexeme}'.");
            }

            // Handle generic type arguments
            List<TypeNode> typeArguments = null;
            if (Match(TokenType.Less))
            {
                typeArguments = new List<TypeNode>();
                do
                {
                    typeArguments.Add(ParseType());
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.Greater, "Expected '>' after type arguments.");
            }

            // Now check what follows
            if (Check(TokenType.LeftBracket))
            {
                // Array creation: new int[5] or new int[] { ... }
                Match(TokenType.LeftBracket);
                
                Expression size = null;
                List<Expression> arguments = new List<Expression>();
                
                // Check if brackets are empty (for array initializer syntax)
                if (!Check(TokenType.RightBracket))
                {
                    size = ParseAssignment();
                    arguments.Add(size);
                }
                
                Consume(TokenType.RightBracket, "Expected ']' after array size.");
                
                // Create array type
                var arrayType = new TypeNode(typeName, typeArguments, true, 1, false);
                
                // Check for array initializer
                List<Expression> initializer = null;
                if (Match(TokenType.LeftBrace))
                {
                    initializer = new List<Expression>();
                    
                    if (!Check(TokenType.RightBrace))
                    {
                        do
                        {
                            initializer.Add(ParseExpression());
                        } while (Match(TokenType.Comma));
                    }
                    
                    Consume(TokenType.RightBrace, "Expected '}' after array initializer.");
                    
                    // If no size was provided but we have an initializer, infer size from initializer
                    if (size == null && initializer != null)
                    {
                        // Create a literal expression with the size based on initializer count
                        size = new LiteralExpression(new Token(TokenType.IntegerLiteral, 
                                                               initializer.Count.ToString(), 
                                                               initializer.Count,
                                                               newToken.Line, newToken.Column, 0, 0, "", _currentSyntaxLevel));
                        arguments.Add(size);
                    }
                }
                else if (size == null)
                {
                    // new int[] without size or initializer is an error
                    throw Error(Current(), "Array creation must have either size or initializer.");
                }
                
                return new NewExpression(newToken, arrayType, arguments, initializer);
            }
            else
            {
                // Check for object initializer without constructor call: new Type { ... }
                if (Check(TokenType.LeftBrace))
                {
                    var type = new TypeNode(typeName, typeArguments, false, 0, false);
                    var arguments = new List<Expression>(); // Empty constructor arguments
                    
                    // Parse object initializer
                    Match(TokenType.LeftBrace);
                    var initializer = new List<Expression>();
                    
                    while (!Check(TokenType.RightBrace) && !IsAtEnd())
                    {
                        // Check if this is a collection initializer (just values) or object initializer (name = value)
                        if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.Assign)
                        {
                            // Object initializer: Property = Value
                            var memberName = Consume(TokenType.Identifier, "Expected member name.");
                            Consume(TokenType.Assign, "Expected '=' in initializer.");
                            var value = ParseExpression();
                            
                            // Create member assignment
                            var memberExpr = new IdentifierExpression(memberName);
                            var assignment = new AssignmentExpression(memberExpr, Previous(), value);
                            initializer.Add(assignment);
                        }
                        else
                        {
                                                            // Collection initializer: just values
                                initializer.Add(ParseAssignment());
                        }
                        
                        if (!Match(TokenType.Comma)) break;
                    }
                    
                    Consume(TokenType.RightBrace, "Expected '}' after initializer.");
                    
                    return new NewExpression(newToken, type, arguments, initializer);
                }
                else if (Check(TokenType.LeftParen))
                {
                    // Constructor call: new TypeName(args)
                    var type = new TypeNode(typeName, typeArguments, false, 0, false);
                    
                    Match(TokenType.LeftParen);
                    var arguments = new List<Expression>();
                    
                    if (!Check(TokenType.RightParen))
                    {
                        do
                        {
                            arguments.Add(ParseAssignment());
                        } while (Match(TokenType.Comma));
                    }
                    
                    Consume(TokenType.RightParen, "Expected ')' after constructor arguments.");
                    
                    // Object or collection initializer
                    List<Expression> initializer = null;
                    if (Match(TokenType.LeftBrace))
                    {
                        initializer = new List<Expression>();
                        
                        while (!Check(TokenType.RightBrace) && !IsAtEnd())
                        {
                            // Check if this is a collection initializer (just values) or object initializer (name = value)
                            if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.Assign)
                            {
                                // Object initializer: Property = Value
                                var memberName = Consume(TokenType.Identifier, "Expected member name.");
                                Consume(TokenType.Assign, "Expected '=' in initializer.");
                                var value = ParseExpression();
                                
                                // Create member assignment
                                var memberExpr = new IdentifierExpression(memberName);
                                var assignment = new AssignmentExpression(memberExpr, Previous(), value);
                                initializer.Add(assignment);
                            }
                            else
                            {
                                // Collection initializer: just values
                                initializer.Add(ParseAssignment());
                            }
                            
                            if (!Match(TokenType.Comma)) break;
                        }
                        
                        Consume(TokenType.RightBrace, "Expected '}' after initializer.");
                    }
                    
                    return new NewExpression(newToken, type, arguments, initializer);
                }
                else
                {
                    // Neither array creation, constructor call, nor object initializer
                    throw Error(Current(), "Expected '(', '[', or '{' after type in new expression.");
                }
            }
        }

        private Expression ParsePrimary()
        {
            // High-level syntax features
            if (_currentSyntaxLevel == SyntaxLevel.High)
            {
                if (Check(TokenType.Identifier) && PeekNext()?.Lexeme == "=>")
                {
                    return ParseLambda();
                }
            }

            // Math symbols and Greek letters as identifiers
            if (Match(TokenType.Pi, TokenType.Tau, TokenType.Epsilon, TokenType.Phi, 
                     TokenType.Gamma, TokenType.Rho, TokenType.Delta, TokenType.Alpha,
                     TokenType.Theta, TokenType.Mu, TokenType.Sigma, TokenType.Omega,
                     TokenType.Lambda, TokenType.Beta, TokenType.Eta, TokenType.Kappa,
                     TokenType.Nu, TokenType.Xi, TokenType.Omicron, TokenType.Upsilon,
                     TokenType.Chi, TokenType.Psi, TokenType.Zeta, TokenType.Iota))
            {
                var symbol = Previous();
                return new IdentifierExpression(new Token(TokenType.Identifier, symbol.Lexeme, null,
                                                         symbol.Line, symbol.Column, 0, 0, "", _currentSyntaxLevel));
            }

            // Mathematical operators as identifiers
            if (Match(TokenType.Infinity, TokenType.Integral, TokenType.Summation, 
                     TokenType.Product, TokenType.SquareRoot, TokenType.CubeRoot,
                     TokenType.PartialDerivative, TokenType.Nabla))
            {
                var symbol = Previous();
                return new IdentifierExpression(new Token(TokenType.Identifier, symbol.Lexeme, null,
                                                         symbol.Line, symbol.Column, 0, 0, "", _currentSyntaxLevel));
            }

            // Literals
            if (Match(TokenType.BooleanLiteral, TokenType.NullLiteral))
            {
                return new LiteralExpression(Previous());
            }

            if (Match(TokenType.IntegerLiteral, TokenType.FloatLiteral, TokenType.DoubleLiteral,
                     TokenType.DecimalLiteral, TokenType.HexLiteral, TokenType.BinaryLiteral,
                     TokenType.OctalLiteral))
            {
                return new LiteralExpression(Previous());
            }

            if (Match(TokenType.StringLiteral, TokenType.CharLiteral))
            {
                return new LiteralExpression(Previous());
            }

            if (Match(TokenType.InterpolatedString))
            {
                return ParseInterpolatedString(Previous());
            }

            // Special expressions
            if (Match(TokenType.This))
            {
                return new ThisExpression(Previous());
            }

            if (Match(TokenType.Base, TokenType.Super))
            {
                return new BaseExpression(Previous());
            }
            
            // Stackalloc expression for low-level memory allocation
            if (Match(TokenType.Stackalloc))
            {
                return ParseStackallocExpression(Previous());
            }

            // Identifiers (regular or Greek letters/math symbols)
            if (Match(TokenType.Identifier))
            {
                return new IdentifierExpression(Previous());
            }

            if (IsGreekLetterOrMathSymbol(Current().Type))
            {
                var token = Advance();
                return new IdentifierExpression(token);
            }
            
            // Allow contextual keywords as identifiers in expressions
            if (Match(TokenType.Data, TokenType.Component, TokenType.System, TokenType.Entity))
            {
                var token = Previous();
                return new IdentifierExpression(new Token(TokenType.Identifier, token.Lexeme, null,
                                                         token.Line, token.Column, 0, 0, "", _currentSyntaxLevel));
            }

            // Grouping
            if (Match(TokenType.LeftParen))
            {
                // Check if this is a cast expression: (type) expression
                var savedPosition = _current;
                
                // Try to parse a type
                if (PeekType() != null)
                {
                    // Try to parse as cast expression
                    var type = ParseType();
                    
                    // If we successfully parsed a type and the next token is ')', it's a cast
                    if (Match(TokenType.RightParen))
                    {
                        // This is a cast expression
                        var castToken = Previous();
                        var expr = ParseUnary(); // Cast has same precedence as unary
                        return new CastExpression(castToken, type, expr);
                    }
                    else
                    {
                        // Not a cast, restore position and parse as grouping or tuple
                        _current = savedPosition;
                    }
                }
                
                // Check if this is a tuple literal by looking for comma after first expression
                var tupleCheckPosition = _current;
                var firstExpr = ParseExpression();
                
                // If we find a comma, this is a tuple literal
                if (Match(TokenType.Comma))
                {
                    var tupleElements = new List<Expression> { firstExpr };
                    
                    // Parse additional tuple elements
                    do
                    {
                        tupleElements.Add(ParseExpression());
                    } while (Match(TokenType.Comma));
                    
                    Consume(TokenType.RightParen, "Expected ')' after tuple elements.");
                    
                    // Create a tuple expression - for now, use ArrayExpression with a special marker
                    // In a real implementation, you'd want a TupleExpression AST node
                    return new ArrayExpression(Previous(), tupleElements);
                }
                else
                {
                    // This is a regular grouping expression
                    Consume(TokenType.RightParen, "Expected ')' after expression.");
                    return firstExpr;
                }
            }

            // Array literals
            if (Match(TokenType.LeftBracket))
            {
                return ParseArrayLiteral();
            }
            
            // Array/Collection initializers with braces: { 1, 2, 3 }
            if (Match(TokenType.LeftBrace))
            {
                var elements = new List<Expression>();
                
                if (!Check(TokenType.RightBrace))
                {
                    do
                    {
                        elements.Add(ParseExpression());
                    } while (Match(TokenType.Comma));
                }
                
                Consume(TokenType.RightBrace, "Expected '}' after initializer.");
                
                return new ArrayExpression(Previous(), elements);
            }

            // Vector/Matrix literals
            if (Match(TokenType.Vector))
            {
                return ParseVectorLiteral();
            }

            if (Match(TokenType.Matrix))
            {
                return ParseMatrixLiteral();
            }

            if (Match(TokenType.Quaternion))
            {
                return ParseQuaternionLiteral();
            }

            // Lambda
            if (Check(TokenType.LeftParen) && CheckLambda())
            {
                return ParseLambda();
            }

            // Throw expressions (C# 7.0+ feature)
            if (Match(TokenType.Throw))
            {
                var throwToken = Previous();
                var expression = ParseAssignment(); // Use full expression parsing for throw operand
                return new ThrowExpression(throwToken, expression);
            }

            // Allow using 'transform' keyword as an identifier when it appears in expression context
            if (Match(TokenType.Transform))
            {
                // Treat it the same way as an identifier expression so user code can use a variable named 'transform'.
                return new IdentifierExpression(Previous());
            }

            // Handle unknown tokens gracefully - treat them as identifiers
            if (Current().Type == TokenType.Unknown)
            {
                var token = Advance();
                return new IdentifierExpression(new Token(TokenType.Identifier, token.Lexeme, null,
                                                         token.Line, token.Column, 0, 0, token.FileName, _currentSyntaxLevel));
            }
            
            // Only convert non-keywords to identifiers in expression context  
            // Exclude common keywords that should never be treated as identifiers in expressions
            var excludedKeywords = new HashSet<TokenType>
            {
                TokenType.Void, TokenType.Int, TokenType.Double, TokenType.String, TokenType.Bool,
                TokenType.Class, TokenType.Interface, TokenType.Struct, TokenType.Enum,
                TokenType.Public, TokenType.Private, TokenType.Protected, TokenType.Static,
                TokenType.If, TokenType.Else, TokenType.While, TokenType.For, TokenType.Return,
                TokenType.Break, TokenType.Continue, TokenType.Try, TokenType.Catch, TokenType.Finally,
                TokenType.New, TokenType.Using, TokenType.Import, TokenType.Namespace
            };
            
            // If we reach here and have a token with non-empty lexeme that's not a reserved keyword, treat it as an identifier
            if (!string.IsNullOrEmpty(Current().Lexeme) && !excludedKeywords.Contains(Current().Type))
            {
                var token = Advance();
                return new IdentifierExpression(new Token(TokenType.Identifier, token.Lexeme, null,
                                                         token.Line, token.Column, 0, 0, token.FileName, _currentSyntaxLevel));
            }
            
            throw Error(Current(), "Expected expression.");
        }

        private Expression ParseInterpolatedString(Token stringToken)
        {
            var parts = new List<Expression>();
            var content = stringToken.Value?.ToString() ?? stringToken.Lexeme;
            
            // Parse the interpolated string content
            int i = 0;
            var currentPart = new StringBuilder();
            
            while (i < content.Length)
            {
                if (i < content.Length - 1 && content[i] == '{' && content[i + 1] != '{')
                {
                    // Save the current string part if any
                    if (currentPart.Length > 0)
                    {
                        parts.Add(new LiteralExpression(new Token(TokenType.StringLiteral, currentPart.ToString(), 
                                                                    currentPart.ToString(), stringToken.Line, stringToken.Column, 
                                                                    0, 0, stringToken.FileName, stringToken.SyntaxLevel)));
                        currentPart.Clear();
                    }
                    
                    // Find the matching closing brace
                    i++; // Skip the opening brace
                    var exprStart = i;
                    int braceCount = 1;
                    
                    while (i < content.Length && braceCount > 0)
                    {
                        if (content[i] == '{')
                            braceCount++;
                        else if (content[i] == '}')
                            braceCount--;
                        if (braceCount > 0) i++;
                    }
                    
                    if (braceCount != 0)
                    {
                        throw Error(stringToken, "Unmatched braces in interpolated string.");
                    }
                    
                    // Parse the expression inside the braces
                    var exprCode = content.Substring(exprStart, i - exprStart);
                    
                    // Create a mini-lexer/parser for the expression
                    // For now, we'll create a simple identifier or member access expression
                    var exprParts = exprCode.Split('.');
                    Expression expr = new IdentifierExpression(new Token(TokenType.Identifier, exprParts[0].Trim(), 
                                                              exprParts[0].Trim(), stringToken.Line, stringToken.Column, 
                                                              0, 0, stringToken.FileName, stringToken.SyntaxLevel));
                    
                    for (int j = 1; j < exprParts.Length; j++)
                    {
                        var memberName = exprParts[j].Trim();
                        // Handle method calls in interpolations
                        if (memberName.EndsWith("()"))
                        {
                            memberName = memberName.Substring(0, memberName.Length - 2);
                            var dotToken = new Token(TokenType.Dot, ".", null, stringToken.Line, stringToken.Column, 0, 0, stringToken.FileName, stringToken.SyntaxLevel);
                            var memberToken = new Token(TokenType.Identifier, memberName, memberName, stringToken.Line, stringToken.Column, 0, 0, stringToken.FileName, stringToken.SyntaxLevel);
                            expr = new MemberExpression(expr, dotToken, memberToken);
                            expr = new CallExpression(expr, new List<Expression>());
                        }
                        else
                        {
                            var dotToken = new Token(TokenType.Dot, ".", null, stringToken.Line, stringToken.Column, 0, 0, stringToken.FileName, stringToken.SyntaxLevel);
                            var memberToken = new Token(TokenType.Identifier, memberName, memberName, stringToken.Line, stringToken.Column, 0, 0, stringToken.FileName, stringToken.SyntaxLevel);
                            expr = new MemberExpression(expr, dotToken, memberToken);
                        }
                    }
                    
                    parts.Add(expr);
                    i++; // Skip the closing brace
                }
                else if (i < content.Length - 1 && content[i] == '{' && content[i + 1] == '}')
                {
                    // Escaped brace
                    currentPart.Append('{');
                    i += 2;
                }
                else if (i < content.Length - 1 && content[i] == '}' && content[i + 1] == '}')
                {
                    // Escaped brace
                    currentPart.Append('}');
                    i += 2;
                }
                else
                {
                    currentPart.Append(content[i]);
                    i++;
                }
            }
            
            // Add any remaining string part
            if (currentPart.Length > 0)
            {
                parts.Add(new LiteralExpression(new Token(TokenType.StringLiteral, currentPart.ToString(), 
                                                            currentPart.ToString(), stringToken.Line, stringToken.Column, 
                                                            0, 0, stringToken.FileName, stringToken.SyntaxLevel)));
            }
            
            return new InterpolatedStringExpression(stringToken, parts);
        }

        private Expression ParseArrayLiteral()
        {
            var elements = new List<Expression>();
            
            if (!Check(TokenType.RightBracket))
            {
                var firstElement = ParseExpression();
                
                // Check for Rust-style array initialization: [value; count]
                if (Match(TokenType.Semicolon))
                {
                    var count = ParseExpression();
                    Consume(TokenType.RightBracket, "Expected ']' after array size.");
                    
                    // Create a special array expression that represents repeated initialization
                    // For now, we'll expand it to a full array with repeated elements
                    // In a full implementation, this would be optimized at compile time
                    if (count is LiteralExpression literalCount && literalCount.Value is int countValue)
                    {
                        for (int i = 0; i < countValue; i++)
                        {
                            elements.Add(firstElement);
                        }
                    }
                    else
                    {
                        // If count is not a literal, we'll need special handling in the compiler
                        // For now, just add the first element
                        elements.Add(firstElement);
                    }
                    
                    return new ArrayExpression(Previous(), elements);
                }
                
                // Regular array literal: [elem1, elem2, ...]
                elements.Add(firstElement);
                
                while (Match(TokenType.Comma))
                {
                    // Check for spread operator (...expression)
                    if (Match(TokenType.Spread))
                    {
                        var spreadToken = Previous();
                        var spreadExpression = ParseAssignment();
                        
                        // Create a spread expression - use a special spread expression type
                        // For now, we'll use a binary expression with the spread token
                        elements.Add(new BinaryExpression(null, spreadToken, spreadExpression));
                    }
                    else
                    {
                        elements.Add(ParseExpression());
                    }
                }
            }
            
            Consume(TokenType.RightBracket, "Expected ']' after array elements.");
            
            return new ArrayExpression(Previous(), elements);
        }

        private Expression ParseVectorLiteral()
        {
            var vectorToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'vector'.");
            
            var components = new List<Expression>();
            do
            {
                components.Add(ParseAssignment());
            } while (Match(TokenType.Comma));
            
            Consume(TokenType.RightParen, "Expected ')' after vector components.");
            
            return new VectorExpression(vectorToken, components);
        }

        private Expression ParseMatrixLiteral()
        {
            var matrixToken = Previous();
            Consume(TokenType.LeftBracket, "Expected '[' after 'matrix'.");
            
            var rows = new List<List<Expression>>();
            
            do
            {
                var row = new List<Expression>();
                Consume(TokenType.LeftBracket, "Expected '[' for matrix row.");
                
                do
                {
                                            row.Add(ParseAssignment());
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.RightBracket, "Expected ']' after matrix row.");
                rows.Add(row);
                
            } while (Match(TokenType.Comma));
            
            Consume(TokenType.RightBracket, "Expected ']' after matrix rows.");
            
            return new MatrixExpression(matrixToken, rows);
        }

        private Expression ParseQuaternionLiteral()
        {
            var quaternionToken = Previous();
            Consume(TokenType.LeftParen, "Expected '(' after 'quaternion'.");
            
                            var w = ParseAssignment();
            Consume(TokenType.Comma, "Expected ',' after w component.");
                            var x = ParseAssignment();
            Consume(TokenType.Comma, "Expected ',' after x component.");
                            var y = ParseAssignment();
            Consume(TokenType.Comma, "Expected ',' after y component.");
                            var z = ParseAssignment();
            
            Consume(TokenType.RightParen, "Expected ')' after quaternion components.");
            
            return new QuaternionExpression(quaternionToken, w, x, y, z);
        }

        private bool CheckLambda()
        {
            // Look ahead to check if this is a lambda expression
            // Case 1: Simple lambda: x => expr
            if (Check(TokenType.Identifier) && PeekNext()?.Type == TokenType.DoubleArrow)
            {
                return true;
            }
            
            // Case 2: Parenthesized lambda: (x, y) => expr
            if (Check(TokenType.LeftParen))
            {
                var i = _current + 1;
                int parenCount = 1;
                
                while (i < _tokens.Count && parenCount > 0)
                {
                    if (_tokens[i].Type == TokenType.LeftParen) parenCount++;
                    else if (_tokens[i].Type == TokenType.RightParen) parenCount--;
                    i++;
                }
                
                return i < _tokens.Count && _tokens[i].Type == TokenType.DoubleArrow;
            }
            
            return false;
        }

        private Expression ParseLambda()
        {
            var parameters = new List<Parameter>();
            
            if (Check(TokenType.LeftParen))
            {
                Match(TokenType.LeftParen);
                // Multiple parameters or typed parameters
                if (!Check(TokenType.RightParen))
                {
                    do
                    {
                        // Try to parse a type, but if it fails, assume var
                        TypeNode type;
                        string name;
                        
                        // Check if this looks like a typed parameter (Type Identifier)
                        // We need to distinguish between "int x" and just "x"
                        if (IsKnownTypeName(Current()) && PeekNext()?.Type == TokenType.Identifier)
                        {
                            // Typed parameter: int x, string y, etc.
                            type = ParseType();
                            name = Consume(TokenType.Identifier, "Expected parameter name.").Lexeme;
                        }
                        else
                        {
                            // Just an identifier, assume var type: x, y, etc.
                            // Also accept Greek letters as parameter names
                            var nameToken = ConsumeIdentifierOrGreekLetter("Expected parameter name.");
                            name = nameToken.Lexeme;
                            type = new TypeNode("var");
                        }
                        
                        parameters.Add(new Parameter(type, name));
                    } while (Match(TokenType.Comma));
                }
                
                Consume(TokenType.RightParen, "Expected ')' after parameters.");
            }
            else
            {
                // Single parameter without parentheses
                var name = Consume(TokenType.Identifier, "Expected parameter name.");
                parameters.Add(new Parameter(new TypeNode("var"), name.Lexeme));
            }
            
            Consume(TokenType.DoubleArrow, "Expected '=>' in lambda expression.");
            
            AstNode body;
            if (Check(TokenType.LeftBrace))
            {
                body = ParseBlock();
            }
            else
            {
                body = ParseAssignment();
            }
            
            return new LambdaExpression(parameters, body);
        }
        
        private Expression ParseStackallocExpression(Token stackallocToken)
        {
            // Parse: stackalloc type[size]
            // Note: For stackalloc, we parse just the base type, not an array type
            // The brackets are part of the stackalloc syntax, not the type
            string typeName;
            
            if (Match(TokenType.Void, TokenType.Bool, TokenType.Byte, TokenType.SByte,
                     TokenType.Short, TokenType.UShort, TokenType.Int, TokenType.UInt,
                     TokenType.Long, TokenType.ULong, TokenType.Float, TokenType.Double,
                     TokenType.Decimal, TokenType.Char, TokenType.String, TokenType.Object,
                     TokenType.Dynamic, TokenType.Var))
            {
                typeName = Previous().Type.ToString().ToLower();
            }
            else if (Match(TokenType.Identifier))
            {
                typeName = Previous().Lexeme;
            }
            else
            {
                throw Error(Current(), $"Expected type name after 'stackalloc', but found {Current().Type} '{Current().Lexeme}'.");
            }
            
            var type = new TypeNode(typeName);
            
            // Expect array syntax for stackalloc
            Consume(TokenType.LeftBracket, "Expected '[' after type in stackalloc.");
                            var size = ParseAssignment();
            Consume(TokenType.RightBracket, "Expected ']' after size in stackalloc.");
            
            // Create a special NewExpression variant for stackalloc
            // We'll use a special "stackalloc" type name to distinguish it
            var stackallocType = new TypeNode("stackalloc_" + type.Name, null, true, 1);
            
            return new NewExpression(stackallocToken, stackallocType, new List<Expression> { size });
        }

        #endregion

        #region Helper Methods

        private void SkipAttributes()
        {
            // Process syntax level attributes first
            ProcessSyntaxLevelAttributes();
            
            // Skip attributes in the form [AttributeName] or [AttributeName(args)]
            while (Match(TokenType.LeftBracket))
            {
                // Skip everything until we find the matching right bracket
                int bracketCount = 1;
                while (bracketCount > 0 && !IsAtEnd())
                {
                    if (Match(TokenType.LeftBracket))
                    {
                        bracketCount++;
                    }
                    else if (Match(TokenType.RightBracket))
                    {
                        bracketCount--;
                    }
                    else
                    {
                        Advance();
                    }
                }
            }
            
            // Skip remaining @ attributes that aren't syntax level
            while (Match(TokenType.At))
            {
                // Check for syntax level attributes first
                if (Check(TokenType.HighLevel) || Check(TokenType.MediumLevel) || Check(TokenType.LowLevel))
                {
                    // These should have been processed already
                    Advance();
                }
                else if (Check(TokenType.Repr))
                {
                    // Handle @repr attribute specifically
                    Advance(); // consume 'repr'
                    
                    // If followed by parentheses, skip the parameter list (e.g., @repr(C))
                    if (Match(TokenType.LeftParen))
                    {
                        int parenCount = 1;
                        while (parenCount > 0 && !IsAtEnd())
                        {
                            if (Match(TokenType.LeftParen))
                            {
                                parenCount++;
                            }
                            else if (Match(TokenType.RightParen))
                            {
                                parenCount--;
                            }
                            else
                            {
                                Advance();
                            }
                        }
                    }
                }
                else if (Check(TokenType.Identifier))
                {
                    var attributeName = Current().Lexeme;
                    
                    // Check for alternative syntax level attribute names
                    if (attributeName == "high" || attributeName == "medium" || attributeName == "low")
                    {
                        // These should have been processed already
                        Advance();
                    }
                    else if (attributeName == "repr")
                    {
                        // Handle @repr attribute by identifier as fallback
                        Advance(); // consume 'repr'
                        
                        // If followed by parentheses, skip the parameter list (e.g., @repr(C))
                        if (Match(TokenType.LeftParen))
                        {
                            int parenCount = 1;
                            while (parenCount > 0 && !IsAtEnd())
                            {
                                if (Match(TokenType.LeftParen))
                                {
                                    parenCount++;
                                }
                                else if (Match(TokenType.RightParen))
                                {
                                    parenCount--;
                                }
                                else
                                {
                                    Advance();
                                }
                            }
                        }
                    }
                    else
                    {
                        Advance(); // Skip attribute name
                        
                        // If followed by parentheses, skip the parameter list
                        if (Match(TokenType.LeftParen))
                        {
                            int parenCount = 1;
                            while (parenCount > 0 && !IsAtEnd())
                            {
                                if (Match(TokenType.LeftParen))
                                {
                                    parenCount++;
                                }
                                else if (Match(TokenType.RightParen))
                                {
                                    parenCount--;
                                }
                                else
                                {
                                    Advance();
                                }
                            }
                        }
                    }
                }
                else
                {
                    // If not followed by identifier, just break (malformed attribute)
                    break;
                }
            }
        }
        
        private void ProcessSyntaxLevelAttributes()
        {
            // Process @ syntax level attributes and set the current syntax level
            while (Check(TokenType.At))
            {
                var atToken = Current();
                Advance(); // consume @
                
                if (Check(TokenType.HighLevel))
                {
                    _currentSyntaxLevel = SyntaxLevel.High;
                    Advance(); // consume high level token
                }
                else if (Check(TokenType.MediumLevel))
                {
                    _currentSyntaxLevel = SyntaxLevel.Medium;
                    Advance(); // consume medium level token
                }
                else if (Check(TokenType.LowLevel))
                {
                    _currentSyntaxLevel = SyntaxLevel.Low;
                    Advance(); // consume low level token
                }
                else if (Check(TokenType.Assembly))
                {
                    // @asm functions use assembly-level syntax
                    _currentSyntaxLevel = SyntaxLevel.Assembly;
                    Advance(); // consume asm token
                }
                else if (Check(TokenType.Identifier))
                {
                    var attributeName = Current().Lexeme;
                    
                    // Check for alternative syntax level attribute names
                    if (attributeName == "high")
                    {
                        _currentSyntaxLevel = SyntaxLevel.High;
                        Advance(); // consume identifier
                    }
                    else if (attributeName == "medium")
                    {
                        _currentSyntaxLevel = SyntaxLevel.Medium;
                        Advance(); // consume identifier
                    }
                    else if (attributeName == "low")
                    {
                        _currentSyntaxLevel = SyntaxLevel.Low;
                        Advance(); // consume identifier
                    }
                    else if (attributeName == "asm")
                    {
                        // @asm functions use low-level syntax
                        _currentSyntaxLevel = SyntaxLevel.Low;
                        Advance(); // consume identifier
                    }
                    else
                    {
                        // Not a syntax level attribute, back up and let SkipAttributes handle it
                        _current--; // back up past the @
                        break;
                    }
                }
                else
                {
                    // Not a syntax level attribute, back up and let SkipAttributes handle it
                    _current--; // back up past the @
                    break;
                }
                
                // Skip optional parentheses for attributes like @low() or @high(always)
                if (Match(TokenType.LeftParen))
                {
                    int parenCount = 1;
                    while (parenCount > 0 && !IsAtEnd())
                    {
                        if (Match(TokenType.LeftParen))
                        {
                            parenCount++;
                        }
                        else if (Match(TokenType.RightParen))
                        {
                            parenCount--;
                        }
                        else
                        {
                            Advance();
                        }
                    }
                }
            }
        }

        private List<Modifier> ParseModifiers()
        {
            var modifiers = new List<Modifier>();

            while (true)
            {
                if (Match(TokenType.Public)) modifiers.Add(Modifier.Public);
                else if (Match(TokenType.Private)) modifiers.Add(Modifier.Private);
                else if (Match(TokenType.Protected)) modifiers.Add(Modifier.Protected);
                else if (Match(TokenType.Internal)) modifiers.Add(Modifier.Internal);
                else if (Match(TokenType.Static)) modifiers.Add(Modifier.Static);
                else if (Match(TokenType.Abstract)) modifiers.Add(Modifier.Abstract);
                else if (Match(TokenType.Virtual)) modifiers.Add(Modifier.Virtual);
                else if (Match(TokenType.Override)) modifiers.Add(Modifier.Override);
                else if (Match(TokenType.Sealed)) modifiers.Add(Modifier.Sealed);
                else if (Match(TokenType.Readonly)) modifiers.Add(Modifier.Readonly);
                else if (Match(TokenType.Const)) modifiers.Add(Modifier.Const);
                else if (Match(TokenType.Volatile)) modifiers.Add(Modifier.Volatile);
                else if (Match(TokenType.Unsafe)) modifiers.Add(Modifier.Unsafe);
                else if (Match(TokenType.Async)) modifiers.Add(Modifier.Async);
                else if (Match(TokenType.Partial)) modifiers.Add(Modifier.Partial);
                else break;
            }

            return modifiers;
        }

                private TypeNode ParseFunctionType()
        {
            // Parse (param1, param2, ...) -> returnType
            Consume(TokenType.LeftParen, "Expected '(' for function type.");
            
            var paramTypes = new List<TypeNode>();
            if (!Check(TokenType.RightParen))
            {
                do
                {
                    paramTypes.Add(ParseType());
                } while (Match(TokenType.Comma));
            }
            
            Consume(TokenType.RightParen, "Expected ')' after function parameter types.");
            Consume(TokenType.Arrow, "Expected '->' in function type.");
            
            var returnType = ParseType();
            
            // Create a function type representation as a string
            var functionTypeName = $"({string.Join(", ", paramTypes.Select(p => p.Name))}) -> {returnType.Name}";
            return new TypeNode(functionTypeName);
        }

        private TypeNode ParseType()
        {
            // Check for function type syntax: (int, int) -> int
            if (Check(TokenType.LeftParen))
            {
                return ParseFunctionType();
            }

            // Check for reference types: &type, &mut type, &[type], &mut [type]
            bool isReference = false;
            bool isMutable = false;
            if (Match(TokenType.BitwiseAnd))
            {
                isReference = true;
                // Check for &mut
                if (Match(TokenType.Identifier) && Previous().Lexeme == "mut")
                {
                    isMutable = true;
                }
            }

            // Check for Rust-style fixed-size array syntax: [type; size]
            if (Check(TokenType.LeftBracket))
            {
                Advance(); // consume '['
                var elementType = ParseType();
                
                // Check for fixed-size array syntax [type; size]
                if (Match(TokenType.Semicolon))
                {
                    var sizeExpr = ParseExpression();
                    Consume(TokenType.RightBracket, "Expected ']' after array size.");
                    
                    // Create array type with fixed size notation
                    var arrayTypeName = $"[{elementType.Name}; size]";
                    var arrayType = new TypeNode(arrayTypeName, elementType.TypeArguments, true, 1, elementType.IsNullable, elementType.IsPointer);
                    
                    // If this was a reference type, wrap it
                    if (isReference)
                    {
                        var refPrefix = isMutable ? "&mut " : "&";
                        return new TypeNode(refPrefix + arrayTypeName, arrayType.TypeArguments, arrayType.IsArray, arrayType.ArrayRank, arrayType.IsNullable, arrayType.IsPointer);
                    }
                    return arrayType;
                }
                else
                {
                    // Just [type] - slice type
                    Consume(TokenType.RightBracket, "Expected ']' after slice type.");
                    var sliceTypeName = $"[{elementType.Name}]";
                    var sliceType = new TypeNode(sliceTypeName, elementType.TypeArguments, true, 1, elementType.IsNullable, elementType.IsPointer);
                    
                    // If this was a reference type, wrap it
                    if (isReference)
                    {
                        var refPrefix = isMutable ? "&mut " : "&";
                        return new TypeNode(refPrefix + sliceTypeName, sliceType.TypeArguments, sliceType.IsArray, sliceType.ArrayRank, sliceType.IsNullable, sliceType.IsPointer);
                    }
                    return sliceType;
                }
            }

            // Check for prefix pointer syntax (*char, *int, etc.)
            bool isPointer = Match(TokenType.Multiply);

            string typeName;

            if (Match(TokenType.Void, TokenType.Bool, TokenType.Byte, TokenType.SByte,
                     TokenType.Short, TokenType.UShort, TokenType.Int, TokenType.UInt,
                     TokenType.Long, TokenType.ULong, TokenType.Float, TokenType.Double,
                     TokenType.Decimal, TokenType.Char, TokenType.String, TokenType.Object,
                     TokenType.Dynamic, TokenType.Var))
            {
                typeName = Previous().Type.ToString().ToLower();
            }
            else if (Match(TokenType.Vector, TokenType.Matrix, TokenType.Quaternion, TokenType.Transform))
            {
                typeName = Previous().Lexeme;
            }
            else if (Match(TokenType.Identifier))
            {
                typeName = Previous().Lexeme;
            }
            else
            {
                throw Error(Current(), $"Expected type name, but found {Current().Type} '{Current().Lexeme}'.");
            }

            // Generic type arguments
            List<TypeNode> typeArguments = null;
            if (Match(TokenType.Less))
            {
                typeArguments = new List<TypeNode>();
                do
                {
                    typeArguments.Add(ParseType());
                } while (Match(TokenType.Comma));
                
                Consume(TokenType.Greater, "Expected '>' after type arguments.");
            }

            // Array
            bool isArray = false;
            int arrayRank = 0;
            if (Match(TokenType.LeftBracket))
            {
                isArray = true;
                arrayRank = 1;
                
                while (Match(TokenType.Comma))
                {
                    arrayRank++;
                }
                
                Consume(TokenType.RightBracket, "Expected ']' after array rank.");
            }

            // Nullable
            bool isNullable = Match(TokenType.Question);

            // Support postfix pointer syntax as well (char*)
            if (!isPointer && Match(TokenType.Multiply))
            {
                isPointer = true;
            }

            var typeNode = new TypeNode(typeName, typeArguments, isArray, arrayRank, isNullable, isPointer);
            
            // If this was a reference type (but not an array/slice), wrap it
            if (isReference && !isArray)
            {
                var refPrefix = isMutable ? "&mut " : "&";
                return new TypeNode(refPrefix + typeNode.Name, typeNode.TypeArguments, typeNode.IsArray, typeNode.ArrayRank, typeNode.IsNullable, typeNode.IsPointer);
            }
            
            return typeNode;
        }

        private TypeNode PeekType()
        {
            // Try to peek if the next tokens form a type
            if (Check(TokenType.Void) || Check(TokenType.Bool) || Check(TokenType.Byte) ||
                Check(TokenType.SByte) || Check(TokenType.Short) || Check(TokenType.UShort) ||
                Check(TokenType.Int) || Check(TokenType.UInt) || Check(TokenType.Long) || 
                Check(TokenType.ULong) || Check(TokenType.Float) || Check(TokenType.Double) ||
                Check(TokenType.Decimal) || Check(TokenType.Char) || Check(TokenType.String) || 
                Check(TokenType.Object) || Check(TokenType.Dynamic) || Check(TokenType.Var))
            {
                return new TypeNode(Current().Type.ToString().ToLower());
            }
            
            if (Check(TokenType.Vector) || Check(TokenType.Matrix) || Check(TokenType.Quaternion) || Check(TokenType.Transform))
            {
                return new TypeNode(Current().Lexeme);
            }

            if (Check(TokenType.Identifier))
            {
                return new TypeNode(Current().Lexeme);
            }

            return null;
        }

        private List<Parameter> ParseParameters()
        {
            var parameters = new List<Parameter>();

            if (!Check(TokenType.RightParen))
            {
                do
                {
                    var modifier = ParameterModifier.None;
                    
                    if (Match(TokenType.Ref)) modifier = ParameterModifier.Ref;
                    else if (Match(TokenType.Out)) modifier = ParameterModifier.Out;
                    else if (Match(TokenType.In)) modifier = ParameterModifier.In;
                    else if (Match(TokenType.Params)) modifier = ParameterModifier.Params;

                    var type = ParseType();
                    var name = Consume(TokenType.Identifier, "Expected parameter name.");

                    Expression defaultValue = null;
                    if (Match(TokenType.Assign))
                    {
                        defaultValue = ParseAssignment();
                    }

                    parameters.Add(new Parameter(type, name.Lexeme, defaultValue, modifier));
                } while (Match(TokenType.Comma));
            }

            Consume(TokenType.RightParen, "Expected ')' after parameters.");
            return parameters;
        }

        private List<TypeParameter> ParseTypeParameters()
        {
            if (!Match(TokenType.Less))
            {
                return new List<TypeParameter>();
            }

            var typeParameters = new List<TypeParameter>();

            do
            {
                bool isCovariant = Match(TokenType.Out);
                bool isContravariant = !isCovariant && Match(TokenType.In);

                var name = Consume(TokenType.Identifier, "Expected type parameter name.").Lexeme;

                var constraints = new List<TypeNode>();
                if (Match(TokenType.Colon))
                {
                    do
                    {
                        constraints.Add(ParseType());
                    } while (Match(TokenType.Comma));
                }

                typeParameters.Add(new TypeParameter(name, constraints, isCovariant, isContravariant));
            } while (Match(TokenType.Comma));

            Consume(TokenType.Greater, "Expected '>' after type parameters.");

            return typeParameters;
        }

        private bool Match(params TokenType[] types)
        {
            foreach (var type in types)
            {
                if (Check(type))
                {
                    Advance();
                    return true;
                }
            }
            return false;
        }

        private bool Check(TokenType type)
        {
            if (IsAtEnd()) return false;
            return Current().Type == type;
        }

        private Token Advance()
        {
            if (!IsAtEnd()) _current++;
            return Previous();
        }

        private bool IsAtEnd()
        {
            return Current().Type == TokenType.EndOfFile;
        }

        private Token Current()
        {
            return _tokens[_current];
        }

        private Token Previous()
        {
            return _tokens[_current - 1];
        }

        private Token PeekNext()
        {
            if (_current + 1 >= _tokens.Count) return null;
            return _tokens[_current + 1];
        }

        private Token Consume(TokenType type, string message)
        {
            if (Check(type)) return Advance();
            
            throw Error(Current(), message);
        }

        private ParseException Error(Token token, string message)
        {
            return new ParseException($"[{token.FileName}:{token.Line}:{token.Column}] {message}");
        }

        private void Synchronize()
        {
            Advance();

            while (!IsAtEnd())
            {
                if (Previous().Type == TokenType.Semicolon) return;

                switch (Current().Type)
                {
                    case TokenType.Class:
                    case TokenType.Interface:
                    case TokenType.Struct:
                    case TokenType.Enum:
                    case TokenType.For:
                    case TokenType.If:
                    case TokenType.While:
                    case TokenType.Return:
                        return;
                }

                Advance();
            }
        }

        // Helper method to consume an identifier or Greek letter
        private Token ConsumeIdentifierOrGreekLetter(string message)
        {
            // Check for regular identifier
            if (Check(TokenType.Identifier))
            {
                return Advance();
            }
            
            // Check for Greek letters and math symbols
            if (IsGreekLetterOrMathSymbol(Current().Type))
            {
                return Advance();
            }
            
            // Allow certain keywords to be used as identifiers in variable names
            // This is common in languages where contextual keywords can be identifiers
            if (Check(TokenType.Data) || Check(TokenType.Component) || Check(TokenType.System) || 
                Check(TokenType.Entity) || Check(TokenType.Numbers) || Check(TokenType.Length) ||
                Check(TokenType.Width) || Check(TokenType.Area) || Check(TokenType.Counter))
            {
                return Advance();
            }
            
            throw Error(Current(), message);
        }
        
        // Helper method to check if a token type is a Greek letter or math symbol
        private bool IsGreekLetterOrMathSymbol(TokenType type)
        {
            switch (type)
            {
                // Greek letters
                case TokenType.Pi:
                case TokenType.Tau:
                case TokenType.Epsilon:
                case TokenType.Phi:
                case TokenType.Gamma:
                case TokenType.Rho:
                case TokenType.Delta:
                case TokenType.Alpha:
                case TokenType.Theta:
                case TokenType.Mu:
                case TokenType.Sigma:
                case TokenType.Omega:
                case TokenType.Lambda:
                case TokenType.Beta:
                case TokenType.Eta:
                case TokenType.Kappa:
                case TokenType.Nu:
                case TokenType.Xi:
                case TokenType.Omicron:
                case TokenType.Upsilon:
                case TokenType.Chi:
                case TokenType.Psi:
                case TokenType.Zeta:
                case TokenType.Iota:
                // Math symbols
                case TokenType.Infinity:
                case TokenType.Integral:
                case TokenType.Summation:
                case TokenType.Product:
                case TokenType.SquareRoot:
                case TokenType.CubeRoot:
                case TokenType.PartialDerivative:
                case TokenType.Nabla:
                    return true;
                default:
                    return false;
            }
        }
        
        // Helper method to check if a token represents a known type name
        private bool IsKnownTypeName(Token token)
        {
            switch (token.Type)
            {
                // Built-in types
                case TokenType.Void:
                case TokenType.Bool:
                case TokenType.Byte:
                case TokenType.SByte:
                case TokenType.Short:
                case TokenType.UShort:
                case TokenType.Int:
                case TokenType.UInt:
                case TokenType.Long:
                case TokenType.ULong:
                case TokenType.Float:
                case TokenType.Double:
                case TokenType.Decimal:
                case TokenType.Char:
                case TokenType.String:
                case TokenType.Object:
                case TokenType.Dynamic:
                case TokenType.Var:
                    return true;
                // For identifiers, we could check against a list of known type names
                // but for now, we'll be conservative and assume identifiers are parameter names
                // unless they're followed by another identifier
                case TokenType.Identifier:
                    // We could add a more sophisticated check here if needed
                    return false;
                default:
                    return false;
            }
        }

        private Token ConsumeIdentifier(string message)
        {
            // Allow reserved keywords that can be used as identifiers
            if (Check(TokenType.Identifier) || 
                Check(TokenType.Length) || Check(TokenType.Width) || Check(TokenType.Area) ||
                Check(TokenType.Numbers) || Check(TokenType.Counter) || Check(TokenType.Data) ||
                Check(TokenType.System) || Check(TokenType.Component) || Check(TokenType.Entity) ||
                IsGreekLetterOrMathSymbol(Current().Type))
            {
                return Advance();
            }
            
            throw Error(Current(), message);
        }

        // Public methods needed by MediumLevelParser
        public int GetCurrentPosition()
        {
            return _current;
        }
        
        public void SetPosition(int position)
        {
            _current = position;
        }
        
        // Make key parsing methods accessible to other parsers
        public bool PublicMatch(params TokenType[] types) => Match(types);
        public bool PublicCheck(TokenType type) => Check(type);
        public Token PublicAdvance() => Advance();
        public bool PublicIsAtEnd() => IsAtEnd();
        public Token PublicCurrent() => Current();
        public Token PublicPrevious() => Previous();
        public Token PublicConsume(TokenType type, string message) => Consume(type, message);
        public Expression PublicParseExpression() => ParseExpression();
        public Expression PublicParseAssignment() => ParseAssignment();

        #endregion

        // Helper method to detect variable declaration patterns vs assignments
        private bool IsVariableDeclarationPattern()
        {
            // Don't treat as variable declaration if this is clearly an assignment
            if (Check(TokenType.Identifier) && PeekNext() != null)
            {
                var nextToken = PeekNext().Type;
                // If we see identifier[...] it's an array access assignment, not a declaration
                if (nextToken == TokenType.LeftBracket)
                {
                    return false;
                }
                // If we see identifier = it might be assignment, check if it looks like a type
                if (nextToken == TokenType.Assign)
                {
                    return false;
                }
                // If we see identifier: it's likely a variable declaration with type annotation
                if (nextToken == TokenType.Colon)
                {
                    return true;
                }
            }
            
            // Use PeekType for other cases, but be more conservative
            return PeekType() != null && !Check(TokenType.Identifier);
        }
    }

    public class ParseException : Exception
    {
        public ParseException(string message) : base(message) { }
    }

    // Pattern classes for pattern matching
    public class ConstantPattern : Pattern
    {
        public Expression Value { get; }

        public ConstantPattern(Expression value)
        {
            Value = value;
        }
    }
} 
